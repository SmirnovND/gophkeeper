
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>client: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/SmirnovND/gophkeeper/cmd/client/main.go (0.0%)</option>
				
				<option value="file1">github.com/SmirnovND/gophkeeper/cmd/server/main.go (0.0%)</option>
				
				<option value="file2">github.com/SmirnovND/gophkeeper/docs/docs.go (0.0%)</option>
				
				<option value="file3">github.com/SmirnovND/gophkeeper/internal/command/auth.go (100.0%)</option>
				
				<option value="file4">github.com/SmirnovND/gophkeeper/internal/command/data.go (100.0%)</option>
				
				<option value="file5">github.com/SmirnovND/gophkeeper/internal/command/factory.go (0.0%)</option>
				
				<option value="file6">github.com/SmirnovND/gophkeeper/internal/command/file.go (100.0%)</option>
				
				<option value="file7">github.com/SmirnovND/gophkeeper/internal/config/server/config.go (54.5%)</option>
				
				<option value="file8">github.com/SmirnovND/gophkeeper/internal/container/client/container.go (0.0%)</option>
				
				<option value="file9">github.com/SmirnovND/gophkeeper/internal/container/server/container.go (0.0%)</option>
				
				<option value="file10">github.com/SmirnovND/gophkeeper/internal/controllers/auth_controller.go (100.0%)</option>
				
				<option value="file11">github.com/SmirnovND/gophkeeper/internal/controllers/data_controller.go (67.3%)</option>
				
				<option value="file12">github.com/SmirnovND/gophkeeper/internal/controllers/file_controller.go (100.0%)</option>
				
				<option value="file13">github.com/SmirnovND/gophkeeper/internal/domain/errors.go (0.0%)</option>
				
				<option value="file14">github.com/SmirnovND/gophkeeper/internal/repo/pass.go (0.0%)</option>
				
				<option value="file15">github.com/SmirnovND/gophkeeper/internal/repo/token.go (76.7%)</option>
				
				<option value="file16">github.com/SmirnovND/gophkeeper/internal/repo/user.go (0.0%)</option>
				
				<option value="file17">github.com/SmirnovND/gophkeeper/internal/router/router.go (0.0%)</option>
				
				<option value="file18">github.com/SmirnovND/gophkeeper/internal/service/auth.go (94.1%)</option>
				
				<option value="file19">github.com/SmirnovND/gophkeeper/internal/service/client.go (73.6%)</option>
				
				<option value="file20">github.com/SmirnovND/gophkeeper/internal/service/cloud.go (100.0%)</option>
				
				<option value="file21">github.com/SmirnovND/gophkeeper/internal/service/data.go (71.9%)</option>
				
				<option value="file22">github.com/SmirnovND/gophkeeper/internal/service/token.go (0.0%)</option>
				
				<option value="file23">github.com/SmirnovND/gophkeeper/internal/service/user.go (100.0%)</option>
				
				<option value="file24">github.com/SmirnovND/gophkeeper/internal/usecase/auth.go (100.0%)</option>
				
				<option value="file25">github.com/SmirnovND/gophkeeper/internal/usecase/client.go (85.8%)</option>
				
				<option value="file26">github.com/SmirnovND/gophkeeper/internal/usecase/cloud.go (0.0%)</option>
				
				<option value="file27">github.com/SmirnovND/gophkeeper/internal/usecase/data.go (83.1%)</option>
				
				<option value="file28">github.com/SmirnovND/gophkeeper/pkg/jwt.go (92.3%)</option>
				
				<option value="file29">github.com/SmirnovND/gophkeeper/pkg/path.go (85.7%)</option>
				
				<option value="file30">github.com/SmirnovND/gophkeeper/pkg/str.go (90.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "github.com/SmirnovND/gophkeeper/internal/container/client"
        "github.com/SmirnovND/gophkeeper/internal/interfaces"
        "os"

        "github.com/spf13/cobra"
)

var (
        version       string = "dev"
        buildDate     string = "unknown"
        serverAddress string = "127.0.0.1:8080"
)

var rootCmd = &amp;cobra.Command{
        Use:   "passcli",
        Short: "CLI клиент для управления паролями",
}

func main() <span class="cov0" title="0">{
        fmt.Println(serverAddress)
        diContainer := client.NewContainer(serverAddress)
        var Command interfaces.Command
        diContainer.Invoke(func(cmd interfaces.Command) </span><span class="cov0" title="0">{
                Command = cmd
        }</span>)
        <span class="cov0" title="0">rootCmd.AddCommand(Command.Login())
        rootCmd.AddCommand(Command.UploadCmd())
        rootCmd.AddCommand(Command.DownloadCmd())
        
        // Добавляем команды для работы с текстовыми данными
        rootCmd.AddCommand(Command.SaveTextCmd())
        rootCmd.AddCommand(Command.GetTextCmd())
        rootCmd.AddCommand(Command.DeleteTextCmd())
        
        // Добавляем команды для работы с данными кредитных карт
        rootCmd.AddCommand(Command.SaveCardCmd())
        rootCmd.AddCommand(Command.GetCardCmd())
        rootCmd.AddCommand(Command.DeleteCardCmd())
        
        // Добавляем команды для работы с учетными данными
        rootCmd.AddCommand(Command.SaveCredentialCmd())
        rootCmd.AddCommand(Command.GetCredentialCmd())
        rootCmd.AddCommand(Command.DeleteCredentialCmd())
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        _ "github.com/SmirnovND/gophkeeper/docs"
        "github.com/SmirnovND/gophkeeper/internal/container/server"
        "github.com/SmirnovND/gophkeeper/internal/interfaces"
        "github.com/SmirnovND/gophkeeper/internal/router"
        "github.com/SmirnovND/toolbox/pkg/logger"
        "github.com/SmirnovND/toolbox/pkg/middleware"
        "github.com/SmirnovND/toolbox/pkg/migrations"
        "github.com/jmoiron/sqlx"
        "net/http"
)

func main() <span class="cov0" title="0">{
        if err := Run(); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

func Run() error <span class="cov0" title="0">{
        diContainer := server.NewContainer()

        var cf interfaces.ConfigServer
        diContainer.Invoke(func(c interfaces.ConfigServer) </span><span class="cov0" title="0">{
                cf = c
        }</span>)

        <span class="cov0" title="0">var dbx *sqlx.DB
        diContainer.Invoke(func(db *sqlx.DB) </span><span class="cov0" title="0">{
                dbx = db
        }</span>)

        <span class="cov0" title="0">dbBase := dbx.DB
        migrations.StartMigrations(dbBase)

        return http.ListenAndServe(cf.GetRunAddr(), middleware.ChainMiddleware(
                router.Handler(diContainer),
                logger.WithLogging,
        ))</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/api/data/card/{label}": {
            "get": {
                "description": "Получает данные кредитной карты пользователя по метке",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "data"
                ],
                "summary": "Получить данные кредитной карты",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Bearer токен",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Метка для идентификации данных",
                        "name": "label",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/domain.CardData"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            },
            "post": {
                "description": "Сохраняет данные кредитной карты пользователя",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "data"
                ],
                "summary": "Сохранить данные кредитной карты",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Bearer токен",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Метка для идентификации данных",
                        "name": "label",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Данные кредитной карты",
                        "name": "card",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/domain.CardData"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            },
            "delete": {
                "description": "Удаляет данные кредитной карты пользователя по метке",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "data"
                ],
                "summary": "Удалить данные кредитной карты",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Bearer токен",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Метка для идентификации данных",
                        "name": "label",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/api/data/credential/{label}": {
            "get": {
                "description": "Получает пару логин/пароль пользователя по метке",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "data"
                ],
                "summary": "Получить учетные данные",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Bearer токен",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Метка для идентификации данных",
                        "name": "label",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/domain.CredentialData"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            },
            "post": {
                "description": "Сохраняет пару логин/пароль пользователя",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "data"
                ],
                "summary": "Сохранить учетные данные",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Bearer токен",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Метка для идентификации данных",
                        "name": "label",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Учетные данные",
                        "name": "credential",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/domain.CredentialData"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            },
            "delete": {
                "description": "Удаляет пару логин/пароль пользователя по метке",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "data"
                ],
                "summary": "Удалить учетные данные",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Bearer токен",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Метка для идентификации данных",
                        "name": "label",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/api/data/text/{label}": {
            "get": {
                "description": "Получает произвольный текст пользователя по метке",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "data"
                ],
                "summary": "Получить текстовые данные",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Bearer токен",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Метка для идентификации данных",
                        "name": "label",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/domain.TextData"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            },
            "post": {
                "description": "Сохраняет произвольный текст пользователя",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "data"
                ],
                "summary": "Сохранить текстовые данные",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Bearer токен",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Метка для идентификации данных",
                        "name": "label",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Текстовые данные",
                        "name": "text",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/domain.TextData"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            },
            "delete": {
                "description": "Удаляет произвольный текст пользователя по метке",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "data"
                ],
                "summary": "Удалить текстовые данные",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Bearer токен",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Метка для идентификации данных",
                        "name": "label",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/api/files/download": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Генерирует ссылку для скачивания файла с сервера",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "files"
                ],
                "summary": "Скачивание файла",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Bearer токен авторизации",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Метка файла",
                        "name": "label",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Успешная генерация ссылки, возвращает URL для скачивания файла",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "Ошибка в формате запроса",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "Пользователь не авторизован",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "404": {
                        "description": "Файл не найден",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Внутренняя ошибка сервера",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/api/files/upload": {
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Генерирует ссылку для загрузки файла на сервер",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "files"
                ],
                "summary": "Загрузка файла",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Bearer токен авторизации",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    },
                    {
                        "description": "Информация о загружаемом файле",
                        "name": "fileData",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/domain.FileData"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Успешная генерация ссылки, возвращает URL для загрузки файла",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "Ошибка в формате запроса",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "Пользователь не авторизован",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "413": {
                        "description": "Превышен максимальный размер файла",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Внутренняя ошибка сервера",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/api/user/login": {
            "post": {
                "description": "Авторизует пользователя в системе и возвращает токен авторизации",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Авторизация пользователя",
                "parameters": [
                    {
                        "description": "Учетные данные пользователя",
                        "name": "credentials",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/domain.Credentials"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Успешная авторизация, возвращает статус и токен в заголовке",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "Ошибка в формате запроса",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "Неверный логин или пароль",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Внутренняя ошибка сервера",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/api/user/register": {
            "post": {
                "description": "Регистрирует нового пользователя в системе и возвращает токен авторизации",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Регистрация нового пользователя",
                "parameters": [
                    {
                        "description": "Учетные данные пользователя",
                        "name": "credentials",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/domain.Credentials"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Успешная регистрация, возвращает статус и токен в заголовке",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "Ошибка в формате запроса",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "409": {
                        "description": "Пользователь с таким логином уже существует",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Внутренняя ошибка сервера",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "domain.CardData": {
            "type": "object",
            "properties": {
                "cvv": {
                    "type": "string"
                },
                "expiry_date": {
                    "type": "string"
                },
                "holder": {
                    "type": "string"
                },
                "number": {
                    "type": "string"
                }
            }
        },
        "domain.CredentialData": {
            "type": "object",
            "properties": {
                "login": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                }
            }
        },
        "domain.Credentials": {
            "type": "object",
            "properties": {
                "login": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                }
            }
        },
        "domain.FileData": {
            "type": "object",
            "required": [
                "extension",
                "name"
            ],
            "properties": {
                "extension": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "domain.TextData": {
            "type": "object",
            "properties": {
                "content": {
                    "type": "string"
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "",
        Host:             "",
        BasePath:         "",
        Schemes:          []string{},
        Title:            "",
        Description:      "",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package command

import (
        "fmt"
        "github.com/spf13/cobra"
        "os"
)

func (c *Command) Login() *cobra.Command <span class="cov8" title="1">{
        return &amp;cobra.Command{
                Use:   "login",
                Short: "Авторизация в сервисе",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        var username, password string
                        
                        fmt.Print("Введите логин: ")
                        fmt.Fscanln(os.Stdin, &amp;username)
                        
                        fmt.Print("Введите пароль: ")
                        fmt.Fscanln(os.Stdin, &amp;password)
                        
                        err := c.clientUseCase.Login(username, password)
                        if err != nil </span><span class="cov8" title="1">{
                                fmt.Println("Ошибка авторизации:", err)
                                return
                        }</span>
                        
                        <span class="cov8" title="1">fmt.Println("Успешная авторизация!")</span>
                },
        }
}

func (c *Command) RegisterCmd() *cobra.Command <span class="cov8" title="1">{
        return &amp;cobra.Command{
                Use:   "register",
                Short: "Регистрация в сервисе",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        var username, password, passwordCheck string
                        
                        fmt.Print("Введите логин: ")
                        fmt.Fscanln(os.Stdin, &amp;username)
                        
                        fmt.Print("Введите пароль: ")
                        fmt.Fscanln(os.Stdin, &amp;password)
                        
                        fmt.Print("Введите пароль еще раз: ")
                        fmt.Fscanln(os.Stdin, &amp;passwordCheck)
                        
                        err := c.clientUseCase.Register(username, password, passwordCheck)
                        if err != nil </span><span class="cov8" title="1">{
                                fmt.Println("Ошибка регистрации:", err)
                                return
                        }</span>
                        
                        <span class="cov8" title="1">fmt.Println("Успешная регистрация!")</span>
                },
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package command

import (
        "fmt"
        "github.com/SmirnovND/gophkeeper/internal/domain"
        "github.com/spf13/cobra"
        "os"
)

// SaveTextCmd создает команду для сохранения текстовых данных
func (c *Command) SaveTextCmd() *cobra.Command <span class="cov8" title="1">{
        return &amp;cobra.Command{
                Use:   "save-text",
                Short: "Сохранение текстовых данных",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        var label, content string

                        fmt.Println("Введите уникальное название (label) для текстовых данных:")
                        fmt.Print("&gt; ")
                        fmt.Fscanln(os.Stdin, &amp;label)

                        fmt.Println("Введите текст для сохранения:")
                        fmt.Print("&gt; ")
                        // Используем bufio.Scanner для чтения многострочного текста
                        var buffer string
                        fmt.Fscanln(os.Stdin, &amp;buffer)
                        content = buffer

                        // Создаем структуру TextData
                        textData := &amp;domain.TextData{
                                Content: content,
                        }

                        // Вызываем метод сохранения текста
                        err := c.clientUseCase.SaveText(label, textData)
                        if err != nil </span><span class="cov8" title="1">{
                                fmt.Println("Ошибка при сохранении текста:", err)
                                return
                        }</span>

                        <span class="cov8" title="1">fmt.Println("Текст успешно сохранен!")</span>
                },
        }
}

// GetTextCmd создает команду для получения текстовых данных
func (c *Command) GetTextCmd() *cobra.Command <span class="cov8" title="1">{
        return &amp;cobra.Command{
                Use:   "get-text",
                Short: "Получение текстовых данных",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        var label string

                        fmt.Println("Введите уникальное название (label) текстовых данных для получения:")
                        fmt.Print("&gt; ")
                        fmt.Fscanln(os.Stdin, &amp;label)

                        // Вызываем метод получения текста
                        textData, err := c.clientUseCase.GetText(label)
                        if err != nil </span><span class="cov8" title="1">{
                                fmt.Println("Ошибка при получении текста:", err)
                                return
                        }</span>

                        <span class="cov8" title="1">fmt.Println("\nПолученный текст:")
                        fmt.Println("------------------")
                        fmt.Println(textData.Content)
                        fmt.Println("------------------")</span>
                },
        }
}

// DeleteTextCmd создает команду для удаления текстовых данных
func (c *Command) DeleteTextCmd() *cobra.Command <span class="cov8" title="1">{
        return &amp;cobra.Command{
                Use:   "delete-text",
                Short: "Удаление текстовых данных",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        var label string

                        fmt.Println("Введите уникальное название (label) текстовых данных для удаления:")
                        fmt.Print("&gt; ")
                        fmt.Fscanln(os.Stdin, &amp;label)

                        // Вызываем метод удаления текста
                        err := c.clientUseCase.DeleteText(label)
                        if err != nil </span><span class="cov8" title="1">{
                                fmt.Println("Ошибка при удалении текста:", err)
                                return
                        }</span>

                        <span class="cov8" title="1">fmt.Println("Текст успешно удален!")</span>
                },
        }
}

// SaveCardCmd создает команду для сохранения данных кредитной карты
func (c *Command) SaveCardCmd() *cobra.Command <span class="cov8" title="1">{
        return &amp;cobra.Command{
                Use:   "save-card",
                Short: "Сохранение данных кредитной карты",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        var label, number, holder, expiryDate, cvv string

                        fmt.Println("Введите уникальное название (label) для данных карты:")
                        fmt.Print("&gt; ")
                        fmt.Fscanln(os.Stdin, &amp;label)

                        fmt.Println("Введите номер карты:")
                        fmt.Print("&gt; ")
                        fmt.Fscanln(os.Stdin, &amp;number)

                        fmt.Println("Введите имя держателя карты:")
                        fmt.Print("&gt; ")
                        fmt.Fscanln(os.Stdin, &amp;holder)

                        fmt.Println("Введите срок действия карты (MM/YY):")
                        fmt.Print("&gt; ")
                        fmt.Fscanln(os.Stdin, &amp;expiryDate)

                        fmt.Println("Введите CVV код:")
                        fmt.Print("&gt; ")
                        fmt.Fscanln(os.Stdin, &amp;cvv)

                        // Создаем структуру CardData
                        cardData := &amp;domain.CardData{
                                Number:     number,
                                Holder:     holder,
                                ExpiryDate: expiryDate,
                                CVV:        cvv,
                        }

                        // Вызываем метод сохранения данных карты
                        err := c.clientUseCase.SaveCard(label, cardData)
                        if err != nil </span><span class="cov8" title="1">{
                                fmt.Println("Ошибка при сохранении данных карты:", err)
                                return
                        }</span>

                        <span class="cov8" title="1">fmt.Println("Данные карты успешно сохранены!")</span>
                },
        }
}

// GetCardCmd создает команду для получения данных кредитной карты
func (c *Command) GetCardCmd() *cobra.Command <span class="cov8" title="1">{
        return &amp;cobra.Command{
                Use:   "get-card",
                Short: "Получение данных кредитной карты",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        var label string

                        fmt.Println("Введите уникальное название (label) данных карты для получения:")
                        fmt.Print("&gt; ")
                        fmt.Fscanln(os.Stdin, &amp;label)

                        // Вызываем метод получения данных карты
                        cardData, err := c.clientUseCase.GetCard(label)
                        if err != nil </span><span class="cov8" title="1">{
                                fmt.Println("Ошибка при получении данных карты:", err)
                                return
                        }</span>

                        <span class="cov8" title="1">fmt.Println("\nДанные кредитной карты:")
                        fmt.Println("------------------------")
                        fmt.Println("Номер карты:", cardData.Number)
                        fmt.Println("Держатель карты:", cardData.Holder)
                        fmt.Println("Срок действия:", cardData.ExpiryDate)
                        fmt.Println("CVV код:", cardData.CVV)
                        fmt.Println("------------------------")</span>
                },
        }
}

// DeleteCardCmd создает команду для удаления данных кредитной карты
func (c *Command) DeleteCardCmd() *cobra.Command <span class="cov8" title="1">{
        return &amp;cobra.Command{
                Use:   "delete-card",
                Short: "Удаление данных кредитной карты",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        var label string

                        fmt.Println("Введите уникальное название (label) данных карты для удаления:")
                        fmt.Print("&gt; ")
                        fmt.Fscanln(os.Stdin, &amp;label)

                        // Вызываем метод удаления данных карты
                        err := c.clientUseCase.DeleteCard(label)
                        if err != nil </span><span class="cov8" title="1">{
                                fmt.Println("Ошибка при удалении данных карты:", err)
                                return
                        }</span>

                        <span class="cov8" title="1">fmt.Println("Данные карты успешно удалены!")</span>
                },
        }
}

// SaveCredentialCmd создает команду для сохранения учетных данных
func (c *Command) SaveCredentialCmd() *cobra.Command <span class="cov8" title="1">{
        return &amp;cobra.Command{
                Use:   "save-credential",
                Short: "Сохранение учетных данных (логин/пароль)",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        var label, login, password string

                        fmt.Println("Введите уникальное название (label) для учетных данных:")
                        fmt.Print("&gt; ")
                        fmt.Fscanln(os.Stdin, &amp;label)

                        fmt.Println("Введите логин:")
                        fmt.Print("&gt; ")
                        fmt.Fscanln(os.Stdin, &amp;login)

                        fmt.Println("Введите пароль:")
                        fmt.Print("&gt; ")
                        fmt.Fscanln(os.Stdin, &amp;password)

                        // Создаем структуру CredentialData
                        credentialData := &amp;domain.CredentialData{
                                Login:    login,
                                Password: password,
                        }

                        // Вызываем метод сохранения учетных данных
                        err := c.clientUseCase.SaveCredential(label, credentialData)
                        if err != nil </span><span class="cov8" title="1">{
                                fmt.Println("Ошибка при сохранении учетных данных:", err)
                                return
                        }</span>

                        <span class="cov8" title="1">fmt.Println("Учетные данные успешно сохранены!")</span>
                },
        }
}

// GetCredentialCmd создает команду для получения учетных данных
func (c *Command) GetCredentialCmd() *cobra.Command <span class="cov8" title="1">{
        return &amp;cobra.Command{
                Use:   "get-credential",
                Short: "Получение учетных данных (логин/пароль)",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        var label string

                        fmt.Println("Введите уникальное название (label) учетных данных для получения:")
                        fmt.Print("&gt; ")
                        fmt.Fscanln(os.Stdin, &amp;label)

                        // Вызываем метод получения учетных данных
                        credentialData, err := c.clientUseCase.GetCredential(label)
                        if err != nil </span><span class="cov8" title="1">{
                                fmt.Println("Ошибка при получении учетных данных:", err)
                                return
                        }</span>

                        <span class="cov8" title="1">fmt.Println("\nУчетные данные:")
                        fmt.Println("---------------")
                        fmt.Println("Логин:", credentialData.Login)
                        fmt.Println("Пароль:", credentialData.Password)
                        fmt.Println("---------------")</span>
                },
        }
}

// DeleteCredentialCmd создает команду для удаления учетных данных
func (c *Command) DeleteCredentialCmd() *cobra.Command <span class="cov8" title="1">{
        return &amp;cobra.Command{
                Use:   "delete-credential",
                Short: "Удаление учетных данных (логин/пароль)",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        var label string

                        fmt.Println("Введите уникальное название (label) учетных данных для удаления:")
                        fmt.Print("&gt; ")
                        fmt.Fscanln(os.Stdin, &amp;label)

                        // Вызываем метод удаления учетных данных
                        err := c.clientUseCase.DeleteCredential(label)
                        if err != nil </span><span class="cov8" title="1">{
                                fmt.Println("Ошибка при удалении учетных данных:", err)
                                return
                        }</span>

                        <span class="cov8" title="1">fmt.Println("Учетные данные успешно удалены!")</span>
                },
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package command

import "github.com/SmirnovND/gophkeeper/internal/interfaces"

type Command struct {
        clientUseCase interfaces.ClientUseCase
}

func NewCommand(
        ClientUseCase interfaces.ClientUseCase,
) interfaces.Command <span class="cov0" title="0">{
        return &amp;Command{
                clientUseCase: ClientUseCase,
        }
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package command

import (
        "fmt"
        "github.com/spf13/cobra"
        "os"
)

func (c *Command) UploadCmd() *cobra.Command <span class="cov8" title="1">{
        return &amp;cobra.Command{
                Use:   "upload",
                Short: "Хранение текстовых/бинарных данных",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        var filePath, label string

                        fmt.Println("Введите путь и имя файла:")
                        fmt.Print("&gt; ")
                        fmt.Fscanln(os.Stdin, &amp;filePath)

                        fmt.Println("Введите уникальное название (label) сохраняемого объекта:")
                        fmt.Print("&gt; ")
                        fmt.Fscanln(os.Stdin, &amp;label)

                        resp, err := c.clientUseCase.Upload(filePath, label)
                        if err != nil </span><span class="cov8" title="1">{
                                fmt.Println("Ошибка:", err)
                                return
                        }</span>

                        <span class="cov8" title="1">fmt.Println("Файл успешно загружен:", resp)</span>
                },
        }
}

func (c *Command) DownloadCmd() *cobra.Command <span class="cov8" title="1">{
        return &amp;cobra.Command{
                Use:   "download",
                Short: "Скачивание файла с сервера",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        var label string

                        fmt.Println("Введите уникальное название (label) файла для скачивания:")
                        fmt.Print("&gt; ")
                        fmt.Fscanln(os.Stdin, &amp;label)

                        // Передаем пустую строку в качестве пути, чтобы использовать директорию загрузок по умолчанию
                        err := c.clientUseCase.Download(label)
                        if err != nil </span><span class="cov8" title="1">{
                                fmt.Println("Ошибка при скачивании файла:", err)
                                return
                        }</span>
                },
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package config

import (
        "fmt"
        "github.com/SmirnovND/gophkeeper/internal/interfaces"
        "gopkg.in/yaml.v3"
        "log"
        "os"
)

type Config struct {
        Db    `yaml:"db"`
        App   `yaml:"app"`
        Minio `yaml:"minio"`
}

type Db struct {
        Dsn string `yaml:"dsn"`
}

type Minio struct {
        BucketName string `yaml:"bucket_name"`
        AccessKey  string `yaml:"access_key"`
        SecretKey  string `yaml:"secret_key"`
        Host       string `yaml:"host"`
}

type App struct {
        JwtSecret string `yaml:"jwt_secret"`
        RunAddr   string `yaml:"run_addr"`
}

func (c *Config) GetDBDsn() string <span class="cov8" title="1">{
        return c.Db.Dsn
}</span>

func (c *Config) GetJwtSecret() string <span class="cov8" title="1">{
        return c.App.JwtSecret
}</span>

func (c *Config) GetRunAddr() string <span class="cov8" title="1">{
        return c.App.RunAddr
}</span>

func (c *Config) GetMinioBucketName() string <span class="cov8" title="1">{
        return c.Minio.BucketName
}</span>

func (c *Config) GetMinioAccessKey() string <span class="cov8" title="1">{
        return c.Minio.AccessKey
}</span>

func (c *Config) GetMinioSecretKey() string <span class="cov8" title="1">{
        return c.Minio.SecretKey
}</span>

func (c *Config) GetMinioHost() string <span class="cov8" title="1">{
        return c.Minio.Host
}</span>

func NewConfig() interfaces.ConfigServer <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        log.Println(err)
                }</span>
        }()

        <span class="cov0" title="0">cPath := os.Args[1]
        cf := &amp;Config{}
        cf.LoadConfig(cPath)
        fmt.Println(cf)
        return cf</span>
}

func (c *Config) LoadConfig(patch string) <span class="cov8" title="1">{
        file, err := os.Open(patch)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("ReadConfigFile: ", err)
        }</span>

        <span class="cov8" title="1">decoder := yaml.NewDecoder(file)
        err = decoder.Decode(&amp;c)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("DecodeConfigFile: ", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package client

import (
        "github.com/SmirnovND/gophkeeper/internal/command"
        "github.com/SmirnovND/gophkeeper/internal/interfaces"
        "github.com/SmirnovND/gophkeeper/internal/repo"
        "github.com/SmirnovND/gophkeeper/internal/service"
        "github.com/SmirnovND/gophkeeper/internal/usecase"
        _ "github.com/lib/pq"
        "go.uber.org/dig"
)

// Container - структура контейнера, обертывающая dig-контейнер
type Container struct {
        container *dig.Container
}

func NewContainer(serverAddress string) *Container <span class="cov0" title="0">{
        c := &amp;Container{container: dig.New()}
        c.provideDependencies()
        c.provideRepo()
        c.provideService(serverAddress)
        c.provideUsecase()
        c.provideCommand()
        return c
}</span>

// provideDependencies - функция, регистрирующая зависимости
func (c *Container) provideDependencies() {<span class="cov0" title="0">
}</span>

func (c *Container) provideUsecase() <span class="cov0" title="0">{
        c.container.Provide(usecase.NewClientUseCase)
}</span>

func (c *Container) provideRepo() <span class="cov0" title="0">{
        c.container.Provide(repo.NewTokenStorage)
}</span>

func (c *Container) provideService(serverAddress string) <span class="cov0" title="0">{
        c.container.Provide(service.NewTokenService)

        c.container.Provide(func() interfaces.ClientService </span><span class="cov0" title="0">{
                return service.NewClientService(serverAddress)
        }</span>)
}

func (c *Container) provideCommand() <span class="cov0" title="0">{
        c.container.Provide(command.NewCommand)
}</span>

// Invoke - функция для вызова и инжекта зависимостей
func (c *Container) Invoke(function interface{}) error <span class="cov0" title="0">{
        return c.container.Invoke(function)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package server

import (
        "fmt"
        config "github.com/SmirnovND/gophkeeper/internal/config/server"
        "github.com/SmirnovND/gophkeeper/internal/controllers"
        "github.com/SmirnovND/gophkeeper/internal/interfaces"
        "github.com/SmirnovND/gophkeeper/internal/repo"
        "github.com/SmirnovND/gophkeeper/internal/service"
        "github.com/SmirnovND/gophkeeper/internal/usecase"
        "github.com/SmirnovND/toolbox/pkg/db"
        "github.com/jmoiron/sqlx"
        _ "github.com/lib/pq"
        "github.com/minio/minio-go/v7"
        "github.com/minio/minio-go/v7/pkg/credentials"
        "go.uber.org/dig"
)

// Container - структура контейнера, обертывающая dig-контейнер
type Container struct {
        container *dig.Container
}

func NewContainer() *Container <span class="cov0" title="0">{
        c := &amp;Container{container: dig.New()}
        c.provideDependencies()
        c.provideRepo()
        c.provideService()
        c.provideUsecase()
        c.provideController()
        return c
}</span>

// provideDependencies - функция, регистрирующая зависимости
func (c *Container) provideDependencies() <span class="cov0" title="0">{
        // Регистрируем конфигурацию
        c.container.Provide(config.NewConfig)
        c.container.Provide(func(configServer interfaces.ConfigServer) *sqlx.DB </span><span class="cov0" title="0">{
                return db.NewDB(configServer.GetDBDsn())
        }</span>)
        // Регистрируем DB интерфейс
        // При регистрации:
        <span class="cov0" title="0">c.container.Provide(func(db *sqlx.DB) interfaces.DB </span><span class="cov0" title="0">{
                return NewDBAdapter(db)
        }</span>)

        <span class="cov0" title="0">c.container.Provide(func(configServer interfaces.ConfigServer) *minio.Client </span><span class="cov0" title="0">{
                client, err := minio.New(configServer.GetMinioHost(), &amp;minio.Options{
                        Creds:  credentials.NewStaticV4(configServer.GetMinioAccessKey(), configServer.GetMinioSecretKey(), ""),
                        Secure: false, // Без HTTPS для локальной установки
                })
                if err != nil </span><span class="cov0" title="0">{
                        // Исправление: добавляем сообщение об ошибке в вызов panic
                        panic(fmt.Sprintf("Ошибка создания MinIO клиента: %v", err))</span>
                }

                <span class="cov0" title="0">return client</span>
        })

}

type DBAdapter struct {
        *sqlx.DB
}

func NewDBAdapter(db *sqlx.DB) *DBAdapter <span class="cov0" title="0">{
        return &amp;DBAdapter{db}
}</span>

func (d *DBAdapter) QueryRow(query string, args ...interface{}) *sqlx.Row <span class="cov0" title="0">{
        return d.DB.QueryRowx(query, args...) // Используем QueryRowx вместо QueryRow
}</span>

func (c *Container) provideUsecase() <span class="cov0" title="0">{
        c.container.Provide(usecase.NewAuthUseCase)
        c.container.Provide(usecase.NewCloudUseCase)
        c.container.Provide(usecase.NewDataUseCase)
}</span>

func (c *Container) provideRepo() <span class="cov0" title="0">{
        c.container.Provide(repo.NewUserRepo)
        c.container.Provide(repo.NewUserDataRepo)
}</span>

func (c *Container) provideService() <span class="cov0" title="0">{
        c.container.Provide(service.NewAuthService)
        c.container.Provide(service.NewUserService)
        c.container.Provide(service.NewDataService)

        c.container.Provide(func(minio *minio.Client, configServer interfaces.ConfigServer) interfaces.CloudService </span><span class="cov0" title="0">{
                return service.NewCloud(minio, configServer.GetMinioBucketName())
        }</span>)

}

func (c *Container) provideController() <span class="cov0" title="0">{
        c.container.Provide(controllers.NewAuthController)
        c.container.Provide(controllers.NewFileController)
        c.container.Provide(controllers.NewDataController)
}</span>

// Invoke - функция для вызова и инжекта зависимостей
func (c *Container) Invoke(function interface{}) error <span class="cov0" title="0">{
        return c.container.Invoke(function)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package controllers

import (
        "github.com/SmirnovND/gophkeeper/internal/domain"
        "github.com/SmirnovND/gophkeeper/internal/interfaces"
        "github.com/SmirnovND/toolbox/pkg/paramsparser"
        "net/http"
)

type AuthController struct {
        AuthUseCase interfaces.AuthUseCase
}

func NewAuthController(AuthUseCase interfaces.AuthUseCase) *AuthController <span class="cov8" title="1">{
        return &amp;AuthController{
                AuthUseCase: AuthUseCase,
        }
}</span>

// HandleRegisterJSON godoc
// @Summary Регистрация нового пользователя
// @Description Регистрирует нового пользователя в системе и возвращает токен авторизации
// @Tags auth
// @Accept json
// @Produce json
// @Param credentials body domain.Credentials true "Учетные данные пользователя"
// @Success 200 {object} map[string]string "Успешная регистрация, возвращает статус и токен в заголовке"
// @Failure 400 {object} map[string]string "Ошибка в формате запроса"
// @Failure 409 {object} map[string]string "Пользователь с таким логином уже существует"
// @Failure 500 {object} map[string]string "Внутренняя ошибка сервера"
// @Router /api/user/register [post]
func (a *AuthController) HandleRegisterJSON(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        credentials, err := paramsparser.JSONParse[domain.Credentials](w, r)
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">a.AuthUseCase.Register(w, credentials)</span>
}

// HandleLoginJSON godoc
// @Summary Авторизация пользователя
// @Description Авторизует пользователя в системе и возвращает токен авторизации
// @Tags auth
// @Accept json
// @Produce json
// @Param credentials body domain.Credentials true "Учетные данные пользователя"
// @Success 200 {object} map[string]string "Успешная авторизация, возвращает статус и токен в заголовке"
// @Failure 400 {object} map[string]string "Ошибка в формате запроса"
// @Failure 401 {object} map[string]string "Неверный логин или пароль"
// @Failure 500 {object} map[string]string "Внутренняя ошибка сервера"
// @Router /api/user/login [post]
func (a *AuthController) HandleLoginJSON(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        credentials, err := paramsparser.JSONParse[domain.Credentials](w, r)
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">a.AuthUseCase.Login(w, credentials)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package controllers

import (
        "github.com/SmirnovND/gophkeeper/internal/domain"
        "github.com/SmirnovND/gophkeeper/internal/interfaces"
        "github.com/SmirnovND/toolbox/pkg/paramsparser"
        "github.com/go-chi/chi/v5"
        "net/http"
)

// DataController контроллер для работы с данными пользователя
type DataController struct {
        dataUseCase interfaces.DataUseCase
}

// NewDataController создает новый экземпляр DataController
func NewDataController(dataUseCase interfaces.DataUseCase) *DataController <span class="cov8" title="1">{
        return &amp;DataController{
                dataUseCase: dataUseCase,
        }
}</span>

// SaveCredential сохраняет учетные данные (логин/пароль)
// @Summary Сохранить учетные данные
// @Description Сохраняет пару логин/пароль пользователя
// @Tags data
// @Accept json
// @Produce json
// @Param Authorization header string true "Bearer токен"
// @Param label path string true "Метка для идентификации данных"
// @Param credential body domain.CredentialData true "Учетные данные"
// @Success 200 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/data/credential/{label} [post]
func (c *DataController) SaveCredential(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Получаем метку из URL
        label := chi.URLParam(r, "label")
        if label == "" </span><span class="cov8" title="1">{
                http.Error(w, "метка не предоставлена", http.StatusBadRequest)
                return
        }</span>

        // Получаем данные из тела запроса
        <span class="cov8" title="1">credentialData, err := paramsparser.JSONParse[domain.CredentialData](w, r)
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">c.dataUseCase.SaveCredential(w, r, label, credentialData)</span>
}

// GetCredential получает учетные данные (логин/пароль)
// @Summary Получить учетные данные
// @Description Получает пару логин/пароль пользователя по метке
// @Tags data
// @Accept json
// @Produce json
// @Param Authorization header string true "Bearer токен"
// @Param label path string true "Метка для идентификации данных"
// @Success 200 {object} domain.CredentialData
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/data/credential/{label} [get]
func (c *DataController) GetCredential(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Получаем метку из URL
        label := chi.URLParam(r, "label")
        if label == "" </span><span class="cov0" title="0">{
                http.Error(w, "метка не предоставлена", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">c.dataUseCase.GetCredential(w, r, label)</span>
}

// SaveCard сохраняет данные кредитной карты
// @Summary Сохранить данные кредитной карты
// @Description Сохраняет данные кредитной карты пользователя
// @Tags data
// @Accept json
// @Produce json
// @Param Authorization header string true "Bearer токен"
// @Param label path string true "Метка для идентификации данных"
// @Param card body domain.CardData true "Данные кредитной карты"
// @Success 200 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/data/card/{label} [post]
func (c *DataController) SaveCard(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Получаем метку из URL
        label := chi.URLParam(r, "label")
        if label == "" </span><span class="cov0" title="0">{
                http.Error(w, "метка не предоставлена", http.StatusBadRequest)
                return
        }</span>

        // Получаем данные из тела запроса
        <span class="cov8" title="1">cardData, err := paramsparser.JSONParse[domain.CardData](w, r)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">c.dataUseCase.SaveCard(w, r, label, cardData)</span>
}

// GetCard получает данные кредитной карты
// @Summary Получить данные кредитной карты
// @Description Получает данные кредитной карты пользователя по метке
// @Tags data
// @Accept json
// @Produce json
// @Param Authorization header string true "Bearer токен"
// @Param label path string true "Метка для идентификации данных"
// @Success 200 {object} domain.CardData
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/data/card/{label} [get]
func (c *DataController) GetCard(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Получаем метку из URL
        label := chi.URLParam(r, "label")
        if label == "" </span><span class="cov0" title="0">{
                http.Error(w, "метка не предоставлена", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">c.dataUseCase.GetCard(w, r, label)</span>
}

// SaveText сохраняет текстовые данные
// @Summary Сохранить текстовые данные
// @Description Сохраняет произвольный текст пользователя
// @Tags data
// @Accept json
// @Produce json
// @Param Authorization header string true "Bearer токен"
// @Param label path string true "Метка для идентификации данных"
// @Param text body domain.TextData true "Текстовые данные"
// @Success 200 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/data/text/{label} [post]
func (c *DataController) SaveText(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Получаем метку из URL
        label := chi.URLParam(r, "label")
        if label == "" </span><span class="cov0" title="0">{
                http.Error(w, "метка не предоставлена", http.StatusBadRequest)
                return
        }</span>

        // Получаем данные из тела запроса
        <span class="cov8" title="1">textData, err := paramsparser.JSONParse[domain.TextData](w, r)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">c.dataUseCase.SaveText(w, r, label, textData)</span>
}

// GetText получает текстовые данные
// @Summary Получить текстовые данные
// @Description Получает произвольный текст пользователя по метке
// @Tags data
// @Accept json
// @Produce json
// @Param Authorization header string true "Bearer токен"
// @Param label path string true "Метка для идентификации данных"
// @Success 200 {object} domain.TextData
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/data/text/{label} [get]
func (c *DataController) GetText(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Получаем метку из URL
        label := chi.URLParam(r, "label")
        if label == "" </span><span class="cov0" title="0">{
                http.Error(w, "метка не предоставлена", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">c.dataUseCase.GetText(w, r, label)</span>
}

// DeleteCredential удаляет учетные данные (логин/пароль)
// @Summary Удалить учетные данные
// @Description Удаляет пару логин/пароль пользователя по метке
// @Tags data
// @Accept json
// @Produce json
// @Param Authorization header string true "Bearer токен"
// @Param label path string true "Метка для идентификации данных"
// @Success 200 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/data/credential/{label} [delete]
func (c *DataController) DeleteCredential(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Получаем метку из URL
        label := chi.URLParam(r, "label")
        if label == "" </span><span class="cov0" title="0">{
                http.Error(w, "метка не предоставлена", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">c.dataUseCase.DeleteCredential(w, r, label)</span>
}

// DeleteCard удаляет данные кредитной карты
// @Summary Удалить данные кредитной карты
// @Description Удаляет данные кредитной карты пользователя по метке
// @Tags data
// @Accept json
// @Produce json
// @Param Authorization header string true "Bearer токен"
// @Param label path string true "Метка для идентификации данных"
// @Success 200 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/data/card/{label} [delete]
func (c *DataController) DeleteCard(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Получаем метку из URL
        label := chi.URLParam(r, "label")
        if label == "" </span><span class="cov0" title="0">{
                http.Error(w, "метка не предоставлена", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">c.dataUseCase.DeleteCard(w, r, label)</span>
}

// DeleteText удаляет текстовые данные
// @Summary Удалить текстовые данные
// @Description Удаляет произвольный текст пользователя по метке
// @Tags data
// @Accept json
// @Produce json
// @Param Authorization header string true "Bearer токен"
// @Param label path string true "Метка для идентификации данных"
// @Success 200 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/data/text/{label} [delete]
func (c *DataController) DeleteText(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Получаем метку из URL
        label := chi.URLParam(r, "label")
        if label == "" </span><span class="cov0" title="0">{
                http.Error(w, "метка не предоставлена", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">c.dataUseCase.DeleteText(w, r, label)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package controllers

import (
        "github.com/SmirnovND/gophkeeper/internal/domain"
        "github.com/SmirnovND/gophkeeper/internal/interfaces"
        "github.com/SmirnovND/toolbox/pkg/paramsparser"
        "net/http"
)

type FileController struct {
        FileUseCase interfaces.CloudUseCase
}

func NewFileController(FileUseCase interfaces.CloudUseCase) *FileController <span class="cov8" title="1">{
        return &amp;FileController{
                FileUseCase: FileUseCase,
        }
}</span>

// HandleUploadFile godoc
// @Summary Загрузка файла
// @Description Генерирует ссылку для загрузки файла на сервер
// @Tags files
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Param Authorization header string true "Bearer токен авторизации"
// @Param fileData body domain.FileData true "Информация о загружаемом файле"
// @Success 200 {object} map[string]string "Успешная генерация ссылки, возвращает URL для загрузки файла"
// @Failure 400 {object} map[string]string "Ошибка в формате запроса"
// @Failure 401 {object} map[string]string "Пользователь не авторизован"
// @Failure 413 {object} map[string]string "Превышен максимальный размер файла"
// @Failure 500 {object} map[string]string "Внутренняя ошибка сервера"
// @Router /api/files/upload [post]
func (f *FileController) HandleUploadFile(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        fileData, err := paramsparser.JSONParse[domain.FileData](w, r)
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">f.FileUseCase.GenerateUploadLink(w, r, fileData)</span>
}

// HandleDownloadFile godoc
// @Summary Скачивание файла
// @Description Генерирует ссылку для скачивания файла с сервера
// @Tags files
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Param Authorization header string true "Bearer токен авторизации"
// @Param label query string true "Метка файла"
// @Success 200 {object} map[string]string "Успешная генерация ссылки, возвращает URL для скачивания файла"
// @Failure 400 {object} map[string]string "Ошибка в формате запроса"
// @Failure 401 {object} map[string]string "Пользователь не авторизован"
// @Failure 404 {object} map[string]string "Файл не найден"
// @Failure 500 {object} map[string]string "Внутренняя ошибка сервера"
// @Router /api/files/download [get]
func (f *FileController) HandleDownloadFile(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Получаем метку файла из параметров запроса
        label := r.URL.Query().Get("label")
        if label == "" </span><span class="cov8" title="1">{
                http.Error(w, "Не указана метка файла", http.StatusBadRequest)
                return
        }</span>

        // Генерируем ссылку для скачивания
        <span class="cov8" title="1">f.FileUseCase.GenerateDownloadLink(w, r, label)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package domain

import "errors"

var ErrNotFound = errors.New("not found")
var ErrInsufficientFunds = errors.New("insufficient funds")

type Error struct {
        Message   string
        CodeValue int
}

func (e *Error) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

func (e *Error) Code() int <span class="cov0" title="0">{
        return e.CodeValue
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package repo

import (
        "database/sql"
        "fmt"
        "github.com/SmirnovND/gophkeeper/internal/domain"
        "github.com/SmirnovND/gophkeeper/internal/interfaces"
)

// UserDataRepo реализует интерфейс interfaces.UserDataRepo
type UserDataRepo struct {
        db interfaces.DB
}

// NewUserDataRepo создает новый экземпляр UserDataRepo
func NewUserDataRepo(db interfaces.DB) interfaces.UserDataRepo <span class="cov0" title="0">{
        return &amp;UserDataRepo{
                db: db,
        }
}</span>

// SaveUserData сохраняет данные пользователя в базе данных
// Если запись с таким user_id и label уже существует, она будет обновлена
func (r *UserDataRepo) SaveUserData(userData *domain.UserData) error <span class="cov0" title="0">{
        // Сначала проверяем, существует ли запись с таким user_id и label
        existingData, err := r.FindUserDataByLabel(userData.UserID, userData.Label)
        if err != nil &amp;&amp; err != domain.ErrNotFound </span><span class="cov0" title="0">{
                return fmt.Errorf("error checking existing user data: %w", err)
        }</span>

        // Если запись существует, обновляем ее
        <span class="cov0" title="0">if existingData != nil </span><span class="cov0" title="0">{
                query := `UPDATE "user_data"
                                  SET type = $1, data = $2
                                  WHERE user_id = $3 AND label = $4
                                  RETURNING id, created_at, updated_at`

                err := r.db.QueryRow(query, userData.Type, userData.Data, userData.UserID, userData.Label).
                        Scan(&amp;userData.ID, &amp;userData.CreatedAt, &amp;userData.UpdatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error updating user data: %w", err)
                }</span>
        } else<span class="cov0" title="0"> {
                // Если записи не существует, создаем новую
                query := `INSERT INTO "user_data" (user_id, label, type, data)
                                  VALUES ($1, $2, $3, $4)
                                  RETURNING id, created_at, updated_at`

                err := r.db.QueryRow(query, userData.UserID, userData.Label, userData.Type, userData.Data).
                        Scan(&amp;userData.ID, &amp;userData.CreatedAt, &amp;userData.UpdatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error saving user data: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// FindUserDataByLabel ищет данные пользователя по метке
func (r *UserDataRepo) FindUserDataByLabel(userID, label string) (*domain.UserData, error) <span class="cov0" title="0">{
        query := `SELECT id, user_id, label, type, data, created_at, updated_at
              FROM "user_data"
              WHERE user_id = $1 AND label = $2
              LIMIT 1`
        row := r.db.QueryRow(query, userID, label)

        userData := &amp;domain.UserData{}
        err := row.Scan(
                &amp;userData.ID,
                &amp;userData.UserID,
                &amp;userData.Label,
                &amp;userData.Type,
                &amp;userData.Data,
                &amp;userData.CreatedAt,
                &amp;userData.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, domain.ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("error querying user data: %w", err)</span>
        }

        <span class="cov0" title="0">return userData, nil</span>
}

// DeleteUserData удаляет данные пользователя по ID
func (r *UserDataRepo) DeleteUserData(id string) error <span class="cov0" title="0">{
        query := `DELETE FROM "user_data" WHERE id = $1`

        result, err := r.db.Exec(query, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error deleting user data: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return domain.ErrNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetUserDataByLabelAndType ищет данные пользователя по метке и типу
func (r *UserDataRepo) GetUserDataByLabelAndType(userID, label string, dataType string) (*domain.UserData, error) <span class="cov0" title="0">{
        query := `SELECT id, user_id, label, type, data, created_at, updated_at
              FROM "user_data"
              WHERE user_id = $1 AND label = $2 AND type = $3
              LIMIT 1`
        row := r.db.QueryRow(query, userID, label, dataType)

        userData := &amp;domain.UserData{}
        err := row.Scan(
                &amp;userData.ID,
                &amp;userData.UserID,
                &amp;userData.Label,
                &amp;userData.Type,
                &amp;userData.Data,
                &amp;userData.CreatedAt,
                &amp;userData.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, domain.ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("error querying user data by label and type: %w", err)</span>
        }

        <span class="cov0" title="0">return userData, nil</span>
}

// DeleteUserDataByUserIDAndLabel удаляет данные пользователя по ID пользователя и метке
func (r *UserDataRepo) DeleteUserDataByUserIDAndLabel(userID, label string) error <span class="cov0" title="0">{
        query := `DELETE FROM "user_data" WHERE user_id = $1 AND label = $2`

        result, err := r.db.Exec(query, userID, label)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error deleting user data by user_id and label: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return domain.ErrNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package repo

import (
        "encoding/json"
        "fmt"
        "github.com/SmirnovND/gophkeeper/internal/interfaces"
        "os"
        "path/filepath"
)

// TokenStorage - структура для хранения JWT-токена.
type TokenStorage struct {
}

// AuthData - структура для хранения данных авторизации (токена).
type AuthData struct {
        Token string `json:"token"`
}

// NewTokenStorage создает новый экземпляр TokenStorage.
func NewTokenStorage() interfaces.TokenStorage <span class="cov8" title="1">{
        return &amp;TokenStorage{}
}</span>

// SaveToken сохраняет токен.
func (s *TokenStorage) SaveToken(token string) error <span class="cov8" title="1">{
        // Получаем путь к файлу с конфигурацией
        configPath, err := getConfigPath()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Создаем директорию, если она не существует
        <span class="cov8" title="1">dir := filepath.Dir(configPath)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Создаем структуру с токеном
        <span class="cov8" title="1">authData := AuthData{Token: token}

        // Сохраняем данные
        file, err := os.Create(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // Записываем данные в файл
        return json.NewEncoder(file).Encode(authData)</span>
}

// LoadToken загружает токен.
func (s *TokenStorage) LoadToken() (string, error) <span class="cov8" title="1">{
        // Получаем путь к файлу с конфигурацией
        configPath, err := getConfigPath()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Открываем файл
        <span class="cov8" title="1">file, err := os.Open(configPath)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // Декодируем данные
        var authData AuthData
        if err := json.NewDecoder(file).Decode(&amp;authData); err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        // Возвращаем токен
        <span class="cov8" title="1">if authData.Token == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("token not found")
        }</span>
        <span class="cov8" title="1">return authData.Token, nil</span>
}

// getConfigPath возвращает путь к файлу конфигурации.
var getConfigPath = func() (string, error) <span class="cov0" title="0">{
        dir, err := os.UserConfigDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return filepath.Join(dir, "passcli", "auth.json"), nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package repo

import (
        "database/sql"
        "fmt"
        "github.com/SmirnovND/gophkeeper/internal/domain"
        "github.com/SmirnovND/gophkeeper/internal/interfaces"
)

type UserRepo struct {
        db interfaces.DB
}

func NewUserRepo(db interfaces.DB) interfaces.UserRepo <span class="cov0" title="0">{
        return &amp;UserRepo{
                db: db,
        }
}</span>

func (r *UserRepo) FindUser(login string) (*domain.User, error) <span class="cov0" title="0">{
        query := `SELECT id, login, pass_hash FROM "users"         WHERE login = $1 LIMIT 1`
        row := r.db.QueryRow(query, login)

        user := &amp;domain.User{}
        err := row.Scan(&amp;user.Id, &amp;user.Login, &amp;user.PassHash)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, domain.ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("error querying user: %w", err)</span>
        }

        <span class="cov0" title="0">return user, nil</span>
}

func (r *UserRepo) SaveUser(user *domain.User) error <span class="cov0" title="0">{
        exec := r.db.QueryRow

        // Запрос с RETURNING id, чтобы получить вставленный id
        query := `INSERT INTO "users"         (login, pass_hash) VALUES ($1, $2) RETURNING id`

        // Выполняем запрос и получаем id
        err := exec(query, user.Login, user.PassHash).Scan(&amp;user.Id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error saving user: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package router

import (
        "fmt"
        "github.com/SmirnovND/gophkeeper/internal/container/server"
        "github.com/SmirnovND/gophkeeper/internal/controllers"
        "github.com/SmirnovND/gophkeeper/internal/interfaces"
        "github.com/SmirnovND/toolbox/pkg/auth"
        "github.com/go-chi/chi/v5"
        "github.com/go-chi/chi/v5/middleware"
        httpSwagger "github.com/swaggo/http-swagger"
        "net/http"
)

func Handler(diContainer *server.Container) http.Handler <span class="cov0" title="0">{
        var AuthController *controllers.AuthController
        var FileController *controllers.FileController
        var DataController *controllers.DataController
        var cf interfaces.ConfigServer
        err := diContainer.Invoke(func(
                c interfaces.ConfigServer,
                authControl *controllers.AuthController,
                fileControl *controllers.FileController,
                dataControl *controllers.DataController,
        ) </span><span class="cov0" title="0">{
                AuthController = authControl
                FileController = fileControl
                DataController = dataControl
                cf = c
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                return nil
        }</span>

        <span class="cov0" title="0">r := chi.NewRouter()
        r.Use(middleware.StripSlashes)

        r.Get("/swagger/*", httpSwagger.Handler(
                httpSwagger.URL(fmt.Sprintf("http://%s/swagger/doc.json", cf.GetRunAddr())),
        ))

        r.Post("/api/user/register", AuthController.HandleRegisterJSON)
        r.Post("/api/user/login", AuthController.HandleLoginJSON)

        r.Post("/api/file/upload", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                auth.AuthMiddleware(cf.GetJwtSecret(), http.HandlerFunc(FileController.HandleUploadFile)).ServeHTTP(w, r)
        }</span>)

        <span class="cov0" title="0">r.Get("/api/file/download", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                auth.AuthMiddleware(cf.GetJwtSecret(), http.HandlerFunc(FileController.HandleDownloadFile)).ServeHTTP(w, r)
        }</span>)

        // Маршруты для работы с данными пользователя
        <span class="cov0" title="0">r.Route("/api/data", func(r chi.Router) </span><span class="cov0" title="0">{
                // Применяем middleware аутентификации ко всем маршрутам данных
                r.Use(func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                                auth.AuthMiddleware(cf.GetJwtSecret(), next).ServeHTTP(w, r)
                        }</span>)
                })

                // Маршруты для работы с учетными данными (логин/пароль)
                <span class="cov0" title="0">r.Route("/credential/{label}", func(r chi.Router) </span><span class="cov0" title="0">{
                        r.Post("/", DataController.SaveCredential)
                        r.Get("/", DataController.GetCredential)
                        r.Delete("/", DataController.DeleteCredential)
                }</span>)

                // Маршруты для работы с данными кредитных карт
                <span class="cov0" title="0">r.Route("/card/{label}", func(r chi.Router) </span><span class="cov0" title="0">{
                        r.Post("/", DataController.SaveCard)
                        r.Get("/", DataController.GetCard)
                        r.Delete("/", DataController.DeleteCard)
                }</span>)

                // Маршруты для работы с текстовыми данными
                <span class="cov0" title="0">r.Route("/text/{label}", func(r chi.Router) </span><span class="cov0" title="0">{
                        r.Post("/", DataController.SaveText)
                        r.Get("/", DataController.GetText)
                        r.Delete("/", DataController.DeleteText)
                }</span>)
        })

        // Обработчик для неподходящего метода (405 Method Not Allowed)
        <span class="cov0" title="0">r.MethodNotAllowed(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
        }</span>)

        // Обработчик для несуществующих маршрутов (404 Not Found)
        <span class="cov0" title="0">r.NotFound(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                http.Error(w, "Route not found", http.StatusNotFound)
        }</span>)

        <span class="cov0" title="0">return r</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package service

import (
        "github.com/SmirnovND/gophkeeper/internal/domain"
        "github.com/SmirnovND/gophkeeper/internal/interfaces"
        "github.com/golang-jwt/jwt/v4"
        "golang.org/x/crypto/bcrypt"
        "net/http"
        "time"
)

type AuthService struct {
        cf interfaces.ConfigServer
}

func NewAuthService(cf interfaces.ConfigServer) interfaces.AuthService <span class="cov8" title="1">{
        return &amp;AuthService{
                cf: cf,
        }
}</span>

func (a *AuthService) GenerateToken(login string) (string, error) <span class="cov8" title="1">{
        expirationTime := time.Now().Add(24 * time.Hour)

        claims := &amp;domain.Claims{
                Login: login,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(expirationTime),
                },
        }

        // Генерируем токен
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

        // Подписываем токен секретным ключом
        return token.SignedString([]byte(a.cf.GetJwtSecret()))
}</span>

func (a *AuthService) ValidateToken(tokenString string) (*domain.Claims, error) <span class="cov8" title="1">{
        // Парсим токен
        token, err := jwt.ParseWithClaims(tokenString, &amp;domain.Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                return []byte(a.cf.GetJwtSecret()), nil
        }</span>)

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Проверяем, является ли токен действительным
        <span class="cov8" title="1">if claims, ok := token.Claims.(*domain.Claims); ok &amp;&amp; token.Valid </span><span class="cov8" title="1">{
                return claims, nil
        }</span>

        <span class="cov0" title="0">return nil, err</span>
}

// Хеширование пароля
func (a *AuthService) HashPassword(password string) (string, error) <span class="cov8" title="1">{
        bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        return string(bytes), err
}</span>

// Проверка пароля
func (a *AuthService) CheckPasswordHash(password, hash string) bool <span class="cov8" title="1">{
        err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
        return err == nil
}</span>

func (a *AuthService) SetResponseAuthData(w http.ResponseWriter, token string) <span class="cov8" title="1">{
        // Отправляем токен в заголовке Authorization
        w.Header().Set("Authorization", "Bearer "+token)
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package service

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "github.com/SmirnovND/gophkeeper/internal/domain"
        "github.com/SmirnovND/gophkeeper/internal/interfaces"
        "io"
        "io/ioutil"
        "net/http"
        "os"
)

type ClientService struct {
        client     *http.Client
        serverAddr string
}

func NewClientService(serverAddr string) interfaces.ClientService <span class="cov8" title="1">{
        return &amp;ClientService{
                client:     &amp;http.Client{},
                serverAddr: serverAddr,
        }
}</span>

func (c *ClientService) sendRequest(method, url string, data interface{}) (*http.Response, error) <span class="cov8" title="1">{
        jsonData, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка при маршалинге данных: %w", err)
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequest(method, url, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка при создании запроса: %w", err)
        }</span>
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")

        resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка при выполнении запроса: %w", err)
        }</span>

        <span class="cov8" title="1">return resp, nil</span>
}

func (c *ClientService) Login(login string, password string) (string, error) <span class="cov8" title="1">{
        credentials := domain.Credentials{Login: login, Password: password}
        resp, err := c.sendRequest("POST", "http://"+c.serverAddr+"/api/user/login", credentials)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                return "", fmt.Errorf("ошибка аутентификации, код ответа: %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">token := resp.Header.Get("Authorization")
        if token == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("токен не найден в ответе")
        }</span>

        <span class="cov8" title="1">return token, nil</span>
}

func (c *ClientService) Register(login, password string) (string, error) <span class="cov8" title="1">{
        credentials := domain.Credentials{Login: login, Password: password}
        resp, err := c.sendRequest("POST", "http://"+c.serverAddr+"/api/user/register", credentials)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode == http.StatusConflict </span><span class="cov8" title="1">{
                return "", fmt.Errorf("пользователь с таким логином уже существует")
        }</span> else<span class="cov8" title="1"> if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return "", fmt.Errorf("ошибка регистрации, код ответа: %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">token := resp.Header.Get("Authorization")
        if token == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("токен не найден в ответе")
        }</span>

        <span class="cov8" title="1">return token, nil</span>
}

func (c *ClientService) GetUploadLink(label string, extension string, token string) (string, error) <span class="cov8" title="1">{
        // Запрос на получение ссылки для загрузки файла
        url := "http://" + c.serverAddr + "/api/file/upload"

        // Создаем структуру для запроса с параметрами из аргументов функции
        requestData := struct {
                Name      string `json:"name"`
                Extension string `json:"extension"`
        }{
                Name:      label,
                Extension: extension,
        }

        // Преобразуем структуру в JSON
        jsonData, err := json.Marshal(requestData)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("ошибка при маршалинге данных: %w", err)
        }</span>

        // Создаем запрос вместо использования http.Post для добавления заголовка авторизации
        <span class="cov8" title="1">req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("ошибка при создании запроса: %w", err)
        }</span>

        // Устанавливаем заголовки
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", token)

        // Выполняем запрос
        resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.New(fmt.Sprintf("Ошибка при запросе к серверу: %v\n", err))
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        // Проверяем статус ответа
        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return "", fmt.Errorf("ошибка при получении ссылки для загрузки, код ответа: %d", resp.StatusCode)
        }</span>

        // Чтение ответа сервера
        <span class="cov8" title="1">respBody, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.New(fmt.Sprintf("Ошибка при чтении ответа сервера: %v\n", err))
        }</span>

        // Извлекаем URL из ответа
        <span class="cov8" title="1">var response struct {
                URL         string `json:"url"`
                Description string `json:"description"`
        }
        if err := json.Unmarshal(respBody, &amp;response); err != nil </span><span class="cov0" title="0">{
                return "", errors.New(fmt.Sprintf("Ошибка при парсинге ответа: %v\n", err))
        }</span>

        <span class="cov8" title="1">return response.URL, nil</span>
}

func (c *ClientService) SendFileToServer(url string, file *os.File) (string, error) <span class="cov8" title="1">{
        // Получаем информацию о файле для определения его размера
        fileInfo, err := file.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.New(fmt.Sprintf("Ошибка при получении информации о файле: %v\n", err))
        }</span>

        // Сбрасываем указатель чтения файла в начало
        <span class="cov8" title="1">_, err = file.Seek(0, 0)
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.New(fmt.Sprintf("Ошибка при перемещении указателя файла: %v\n", err))
        }</span>

        // Загрузка файла
        <span class="cov8" title="1">req, err := http.NewRequest("PUT", url, file)
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.New(fmt.Sprintf("Ошибка при подготовке запроса на загрузку: %v\n", err))
        }</span>

        // Устанавливаем заголовки
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/octet-stream")
        req.ContentLength = fileInfo.Size() // Устанавливаем размер файла в заголовке Content-Length

        client := &amp;http.Client{}
        fileUploadResp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.New(fmt.Sprintf("Ошибка при загрузке файла: %v\n", err))
        }</span>
        <span class="cov8" title="1">defer fileUploadResp.Body.Close()

        if fileUploadResp.StatusCode == http.StatusOK </span><span class="cov8" title="1">{
                return "Файл успешно загружен!", nil
        }</span> else<span class="cov0" title="0"> {
                return "", errors.New(fmt.Sprintf("Ошибка при загрузке файла: %s\n", fileUploadResp.Status))
        }</span>
}

func (c *ClientService) GetDownloadLink(label string, token string) (string, *domain.FileMetadata, error) <span class="cov8" title="1">{
        // Формируем URL для запроса на получение ссылки для скачивания
        url := fmt.Sprintf("http://%s/api/file/download?label=%s", c.serverAddr, label)

        // Создаем запрос
        req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("ошибка при создании запроса: %w", err)
        }</span>

        // Устанавливаем заголовок авторизации
        <span class="cov8" title="1">req.Header.Set("Authorization", token)

        // Выполняем запрос
        resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("ошибка при выполнении запроса: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        // Проверяем статус ответа
        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("ошибка при получении ссылки для скачивания, код ответа: %d", resp.StatusCode)
        }</span>

        // Чтение ответа сервера
        <span class="cov8" title="1">respBody, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("ошибка при чтении ответа сервера: %w", err)
        }</span>

        // Извлекаем URL и метаданные из ответа
        <span class="cov8" title="1">var response struct {
                URL         string              `json:"url"`
                Description string              `json:"description"`
                Metadata    domain.FileMetadata `json:"metadata"`
        }
        if err := json.Unmarshal(respBody, &amp;response); err != nil </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("ошибка при парсинге ответа: %w", err)
        }</span>

        <span class="cov8" title="1">return response.URL, &amp;response.Metadata, nil</span>
}

func (c *ClientService) DownloadFileFromServer(url string, outputPath string) error <span class="cov8" title="1">{
        // Создаем запрос на скачивание файла
        req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при создании запроса на скачивание: %w", err)
        }</span>

        // Выполняем запрос
        <span class="cov8" title="1">resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при выполнении запроса на скачивание: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        // Проверяем статус ответа
        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при скачивании файла, код ответа: %d", resp.StatusCode)
        }</span>

        // Создаем файл для сохранения скачанных данных
        <span class="cov8" title="1">outputFile, err := os.Create(outputPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при создании файла для сохранения: %w", err)
        }</span>
        <span class="cov8" title="1">defer outputFile.Close()

        // Копируем данные из ответа в файл
        _, err = io.Copy(outputFile, resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при сохранении файла: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// SaveText сохраняет текстовые данные
func (c *ClientService) SaveText(label string, textData *domain.TextData, token string) error <span class="cov8" title="1">{
        url := fmt.Sprintf("http://%s/api/data/text/%s", c.serverAddr, label)

        // Преобразуем данные в JSON
        jsonData, err := json.Marshal(textData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при маршалинге данных: %w", err)
        }</span>

        // Создаем запрос
        <span class="cov8" title="1">req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при создании запроса: %w", err)
        }</span>

        // Устанавливаем заголовки
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", token)

        // Выполняем запрос
        resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при выполнении запроса: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        // Проверяем статус ответа
        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при сохранении текстовых данных, код ответа: %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetText получает текстовые данные
func (c *ClientService) GetText(label string, token string) (*domain.TextData, error) <span class="cov8" title="1">{
        url := fmt.Sprintf("http://%s/api/data/text/%s", c.serverAddr, label)

        // Создаем запрос
        req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка при создании запроса: %w", err)
        }</span>

        // Устанавливаем заголовки
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", token)

        // Выполняем запрос
        resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка при выполнении запроса: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        // Проверяем статус ответа
        if resp.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("текстовые данные не найдены")
        }</span> else<span class="cov8" title="1"> if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка при получении текстовых данных, код ответа: %d", resp.StatusCode)
        }</span>

        // Читаем ответ
        <span class="cov8" title="1">body, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка при чтении ответа: %w", err)
        }</span>

        // Десериализуем данные
        <span class="cov8" title="1">var textData domain.TextData
        if err := json.Unmarshal(body, &amp;textData); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка при десериализации данных: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;textData, nil</span>
}

// DeleteText удаляет текстовые данные
func (c *ClientService) DeleteText(label string, token string) error <span class="cov8" title="1">{
        url := fmt.Sprintf("http://%s/api/data/text/%s", c.serverAddr, label)

        // Создаем запрос
        req, err := http.NewRequest("DELETE", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при создании запроса: %w", err)
        }</span>

        // Устанавливаем заголовки
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", token)

        // Выполняем запрос
        resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при выполнении запроса: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        // Проверяем статус ответа
        if resp.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                return fmt.Errorf("текстовые данные не найдены")
        }</span> else<span class="cov8" title="1"> if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при удалении текстовых данных, код ответа: %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// SaveCard сохраняет данные кредитной карты
func (c *ClientService) SaveCard(label string, cardData *domain.CardData, token string) error <span class="cov8" title="1">{
        url := fmt.Sprintf("http://%s/api/data/card/%s", c.serverAddr, label)

        // Преобразуем данные в JSON
        jsonData, err := json.Marshal(cardData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при маршалинге данных: %w", err)
        }</span>

        // Создаем запрос
        <span class="cov8" title="1">req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при создании запроса: %w", err)
        }</span>

        // Устанавливаем заголовки
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", token)

        // Выполняем запрос
        resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при выполнении запроса: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        // Проверяем статус ответа
        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при сохранении данных карты, код ответа: %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetCard получает данные кредитной карты
func (c *ClientService) GetCard(label string, token string) (*domain.CardData, error) <span class="cov8" title="1">{
        url := fmt.Sprintf("http://%s/api/data/card/%s", c.serverAddr, label)

        // Создаем запрос
        req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка при создании запроса: %w", err)
        }</span>

        // Устанавливаем заголовки
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", token)

        // Выполняем запрос
        resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка при выполнении запроса: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        // Проверяем статус ответа
        if resp.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("данные карты не найдены")
        }</span> else<span class="cov8" title="1"> if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка при получении данных карты, код ответа: %d", resp.StatusCode)
        }</span>

        // Читаем ответ
        <span class="cov8" title="1">body, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка при чтении ответа: %w", err)
        }</span>

        // Десериализуем данные
        <span class="cov8" title="1">var cardData domain.CardData
        if err := json.Unmarshal(body, &amp;cardData); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка при десериализации данных: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;cardData, nil</span>
}

// DeleteCard удаляет данные кредитной карты
func (c *ClientService) DeleteCard(label string, token string) error <span class="cov8" title="1">{
        url := fmt.Sprintf("http://%s/api/data/card/%s", c.serverAddr, label)

        // Создаем запрос
        req, err := http.NewRequest("DELETE", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при создании запроса: %w", err)
        }</span>

        // Устанавливаем заголовки
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", token)

        // Выполняем запрос
        resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при выполнении запроса: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        // Проверяем статус ответа
        if resp.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                return fmt.Errorf("данные карты не найдены")
        }</span> else<span class="cov8" title="1"> if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при удалении данных карты, код ответа: %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// SaveCredential сохраняет учетные данные
func (c *ClientService) SaveCredential(label string, credentialData *domain.CredentialData, token string) error <span class="cov8" title="1">{
        url := fmt.Sprintf("http://%s/api/data/credential/%s", c.serverAddr, label)

        // Преобразуем данные в JSON
        jsonData, err := json.Marshal(credentialData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при маршалинге данных: %w", err)
        }</span>

        // Создаем запрос
        <span class="cov8" title="1">req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при создании запроса: %w", err)
        }</span>

        // Устанавливаем заголовки
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", token)

        // Выполняем запрос
        resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при выполнении запроса: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        // Проверяем статус ответа
        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при сохранении учетных данных, код ответа: %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetCredential получает учетные данные
func (c *ClientService) GetCredential(label string, token string) (*domain.CredentialData, error) <span class="cov8" title="1">{
        url := fmt.Sprintf("http://%s/api/data/credential/%s", c.serverAddr, label)

        // Создаем запрос
        req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка при создании запроса: %w", err)
        }</span>

        // Устанавливаем заголовки
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", token)

        // Выполняем запрос
        resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка при выполнении запроса: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        // Проверяем статус ответа
        if resp.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("учетные данные не найдены")
        }</span> else<span class="cov8" title="1"> if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка при получении учетных данных, код ответа: %d", resp.StatusCode)
        }</span>

        // Читаем ответ
        <span class="cov8" title="1">body, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка при чтении ответа: %w", err)
        }</span>

        // Десериализуем данные
        <span class="cov8" title="1">var credentialData domain.CredentialData
        if err := json.Unmarshal(body, &amp;credentialData); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка при десериализации данных: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;credentialData, nil</span>
}

// DeleteCredential удаляет учетные данные
func (c *ClientService) DeleteCredential(label string, token string) error <span class="cov8" title="1">{
        url := fmt.Sprintf("http://%s/api/data/credential/%s", c.serverAddr, label)

        // Создаем запрос
        req, err := http.NewRequest("DELETE", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при создании запроса: %w", err)
        }</span>

        // Устанавливаем заголовки
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", token)

        // Выполняем запрос
        resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при выполнении запроса: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        // Проверяем статус ответа
        if resp.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                return fmt.Errorf("учетные данные не найдены")
        }</span> else<span class="cov8" title="1"> if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при удалении учетных данных, код ответа: %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package service

import (
        "context"
        "github.com/SmirnovND/gophkeeper/internal/interfaces"
        "net/url"
        "time"
)

type Cloud struct {
        minio      interfaces.MinioClientInterface
        bucketName string
}

func NewCloud(minio interfaces.MinioClientInterface, bucketName string) interfaces.CloudService <span class="cov8" title="1">{
        return &amp;Cloud{
                minio:      minio,
                bucketName: bucketName,
        }
}</span>

func (c *Cloud) GenerateUploadLink(fileName string) (string, error) <span class="cov8" title="1">{
        ctx := context.Background()
        presignedURL, err := c.minio.PresignedPutObject(ctx, c.bucketName, fileName, 15*time.Minute)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">return presignedURL.String(), nil</span>
}

func (c *Cloud) GenerateDownloadLink(fileName string) (string, error) <span class="cov8" title="1">{
        ctx := context.Background()
        // Устанавливаем срок действия ссылки на 15 минут
        reqParams := make(url.Values)
        presignedURL, err := c.minio.PresignedGetObject(ctx, c.bucketName, fileName, 15*time.Minute, reqParams)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">return presignedURL.String(), nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package service

import (
        "encoding/json"
        "fmt"
        "github.com/SmirnovND/gophkeeper/internal/domain"
        "github.com/SmirnovND/gophkeeper/internal/interfaces"
)

// DataService реализует интерфейс для работы с данными пользователя
type DataService struct {
        repo     interfaces.UserDataRepo
        userRepo interfaces.UserRepo
}

// NewDataService создает новый экземпляр DataService
func NewDataService(repo interfaces.UserDataRepo, userRepo interfaces.UserRepo) interfaces.DataService <span class="cov8" title="1">{
        return &amp;DataService{
                repo:     repo,
                userRepo: userRepo,
        }
}</span>

// SaveFileMetadata сохраняет метаданные файла
func (c *DataService) SaveFileMetadata(login string, label string, fileData *domain.FileData) error <span class="cov8" title="1">{
        // Получаем пользователя по логину
        user, err := c.userRepo.FindUser(login)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("Ошибка при поиске пользователя: %w", err)
        }</span>

        // Создаем метаданные файла (сохраняем только имя и расширение, URL не сохраняем)
        <span class="cov8" title="1">fileMetadata := domain.FileMetadata{
                FileName:  fileData.Name,
                Extension: fileData.Extension,
        }

        // Преобразуем метаданные в JSON
        metadataJSON, err := json.Marshal(fileMetadata)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при маршалинге метаданных файла: %w", err)
        }</span>

        // Создаем запись в таблице user_data
        <span class="cov8" title="1">userData := &amp;domain.UserData{
                UserID: user.Id,
                Label:  label,
                Type:   domain.UserDataTypeFile,
                Data:   metadataJSON,
        }

        // Сохраняем запись в базе данных
        err = c.repo.SaveUserData(userData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при сохранении метаданных файла: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetFileMetadata получает метаданные файла
func (c *DataService) GetFileMetadata(login string, label string) (*domain.FileMetadata, error) <span class="cov8" title="1">{
        // Получаем пользователя по логину
        user, err := c.userRepo.FindUser(login)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("ошибка при поиске пользователя: %w", err)
        }</span>

        // Получаем данные пользователя по метке и типу
        <span class="cov8" title="1">userData, err := c.repo.GetUserDataByLabelAndType(user.Id, label, domain.UserDataTypeFile)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("ошибка при получении метаданных файла: %w", err)
        }</span>

        // Если данные не найдены
        <span class="cov8" title="1">if userData == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("метаданные файла не найдены")
        }</span>

        // Десериализуем метаданные из JSON
        <span class="cov8" title="1">var fileMetadata domain.FileMetadata
        err = json.Unmarshal(userData.Data, &amp;fileMetadata)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка при десериализации метаданных файла: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;fileMetadata, nil</span>
}

// SaveCredential сохраняет учетные данные (логин/пароль)
func (c *DataService) SaveCredential(login string, label string, credentialData *domain.CredentialData) error <span class="cov8" title="1">{
        // Получаем пользователя по логину
        user, err := c.userRepo.FindUser(login)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при поиске пользователя: %w", err)
        }</span>

        // Преобразуем данные в JSON
        <span class="cov8" title="1">dataJSON, err := json.Marshal(credentialData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при маршалинге учетных данных: %w", err)
        }</span>

        // Создаем запись в таблице user_data
        <span class="cov8" title="1">userData := &amp;domain.UserData{
                UserID: user.Id,
                Label:  label,
                Type:   domain.UserDataTypeCredential,
                Data:   dataJSON,
        }

        // Сохраняем запись в базе данных
        err = c.repo.SaveUserData(userData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при сохранении учетных данных: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetCredential получает учетные данные (логин/пароль)
func (c *DataService) GetCredential(login string, label string) (*domain.CredentialData, error) <span class="cov8" title="1">{
        // Получаем пользователя по логину
        user, err := c.userRepo.FindUser(login)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка при поиске пользователя: %w", err)
        }</span>

        // Получаем данные пользователя по метке и типу
        <span class="cov8" title="1">userData, err := c.repo.GetUserDataByLabelAndType(user.Id, label, domain.UserDataTypeCredential)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка при получении учетных данных: %w", err)
        }</span>

        // Если данные не найдены
        <span class="cov8" title="1">if userData == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("учетные данные не найдены")
        }</span>

        // Десериализуем данные из JSON
        <span class="cov8" title="1">var credentialData domain.CredentialData
        err = json.Unmarshal(userData.Data, &amp;credentialData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка при десериализации учетных данных: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;credentialData, nil</span>
}

// SaveCard сохраняет данные кредитной карты
func (c *DataService) SaveCard(login string, label string, cardData *domain.CardData) error <span class="cov8" title="1">{
        // Получаем пользователя по логину
        user, err := c.userRepo.FindUser(login)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при поиске пользователя: %w", err)
        }</span>

        // Преобразуем данные в JSON
        <span class="cov8" title="1">dataJSON, err := json.Marshal(cardData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при маршалинге данных карты: %w", err)
        }</span>

        // Создаем запись в таблице user_data
        <span class="cov8" title="1">userData := &amp;domain.UserData{
                UserID: user.Id,
                Label:  label,
                Type:   domain.UserDataTypeCard,
                Data:   dataJSON,
        }

        // Сохраняем запись в базе данных
        err = c.repo.SaveUserData(userData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при сохранении данных карты: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetCard получает данные кредитной карты
func (c *DataService) GetCard(login string, label string) (*domain.CardData, error) <span class="cov8" title="1">{
        // Получаем пользователя по логину
        user, err := c.userRepo.FindUser(login)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка при поиске пользователя: %w", err)
        }</span>

        // Получаем данные пользователя по метке и типу
        <span class="cov8" title="1">userData, err := c.repo.GetUserDataByLabelAndType(user.Id, label, domain.UserDataTypeCard)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка при получении данных карты: %w", err)
        }</span>

        // Если данные не найдены
        <span class="cov8" title="1">if userData == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("данные карты не найдены")
        }</span>

        // Десериализуем данные из JSON
        <span class="cov8" title="1">var cardData domain.CardData
        err = json.Unmarshal(userData.Data, &amp;cardData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка при десериализации данных карты: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;cardData, nil</span>
}

// SaveText сохраняет текстовые данные
func (c *DataService) SaveText(login string, label string, textData *domain.TextData) error <span class="cov8" title="1">{
        // Получаем пользователя по логину
        user, err := c.userRepo.FindUser(login)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при поиске пользователя: %w", err)
        }</span>

        // Преобразуем данные в JSON
        <span class="cov8" title="1">dataJSON, err := json.Marshal(textData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при маршалинге текстовых данных: %w", err)
        }</span>

        // Создаем запись в таблице user_data
        <span class="cov8" title="1">userData := &amp;domain.UserData{
                UserID: user.Id,
                Label:  label,
                Type:   domain.UserDataTypeText,
                Data:   dataJSON,
        }

        // Сохраняем запись в базе данных
        err = c.repo.SaveUserData(userData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при сохранении текстовых данных: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetText получает текстовые данные
func (c *DataService) GetText(login string, label string) (*domain.TextData, error) <span class="cov8" title="1">{
        // Получаем пользователя по логину
        user, err := c.userRepo.FindUser(login)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка при поиске пользователя: %w", err)
        }</span>

        // Получаем данные пользователя по метке и типу
        <span class="cov8" title="1">userData, err := c.repo.GetUserDataByLabelAndType(user.Id, label, domain.UserDataTypeText)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка при получении текстовых данных: %w", err)
        }</span>

        // Если данные не найдены
        <span class="cov8" title="1">if userData == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("текстовые данные не найдены")
        }</span>

        // Десериализуем данные из JSON
        <span class="cov8" title="1">var textData domain.TextData
        err = json.Unmarshal(userData.Data, &amp;textData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка при десериализации текстовых данных: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;textData, nil</span>
}

// DeleteFileMetadata удаляет метаданные файла
func (c *DataService) DeleteFileMetadata(login string, label string) error <span class="cov8" title="1">{
        // Получаем пользователя по логину
        user, err := c.userRepo.FindUser(login)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при поиске пользователя: %w", err)
        }</span>

        // Удаляем данные пользователя по метке и типу
        <span class="cov8" title="1">userData, err := c.repo.GetUserDataByLabelAndType(user.Id, label, domain.UserDataTypeFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при получении метаданных файла: %w", err)
        }</span>

        // Если данные не найдены
        <span class="cov8" title="1">if userData == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("метаданные файла не найдены")
        }</span>

        // Удаляем запись
        <span class="cov8" title="1">err = c.repo.DeleteUserData(userData.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при удалении метаданных файла: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// DeleteCredential удаляет учетные данные (логин/пароль)
func (c *DataService) DeleteCredential(login string, label string) error <span class="cov8" title="1">{
        // Получаем пользователя по логину
        user, err := c.userRepo.FindUser(login)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при поиске пользователя: %w", err)
        }</span>

        // Удаляем данные пользователя по метке и типу
        <span class="cov8" title="1">userData, err := c.repo.GetUserDataByLabelAndType(user.Id, label, domain.UserDataTypeCredential)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при получении учетных данных: %w", err)
        }</span>

        // Если данные не найдены
        <span class="cov8" title="1">if userData == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("учетные данные не найдены")
        }</span>

        // Удаляем запись
        <span class="cov8" title="1">err = c.repo.DeleteUserData(userData.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при удалении учетных данных: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// DeleteCard удаляет данные кредитной карты
func (c *DataService) DeleteCard(login string, label string) error <span class="cov8" title="1">{
        // Получаем пользователя по логину
        user, err := c.userRepo.FindUser(login)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при поиске пользователя: %w", err)
        }</span>

        // Удаляем данные пользователя по метке и типу
        <span class="cov8" title="1">userData, err := c.repo.GetUserDataByLabelAndType(user.Id, label, domain.UserDataTypeCard)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при получении данных карты: %w", err)
        }</span>

        // Если данные не найдены
        <span class="cov8" title="1">if userData == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("данные карты не найдены")
        }</span>

        // Удаляем запись
        <span class="cov8" title="1">err = c.repo.DeleteUserData(userData.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при удалении данных карты: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// DeleteText удаляет текстовые данные
func (c *DataService) DeleteText(login string, label string) error <span class="cov8" title="1">{
        // Получаем пользователя по логину
        user, err := c.userRepo.FindUser(login)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при поиске пользователя: %w", err)
        }</span>

        // Удаляем данные пользователя по метке и типу
        <span class="cov8" title="1">userData, err := c.repo.GetUserDataByLabelAndType(user.Id, label, domain.UserDataTypeText)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при получении текстовых данных: %w", err)
        }</span>

        // Если данные не найдены
        <span class="cov8" title="1">if userData == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("текстовые данные не найдены")
        }</span>

        // Удаляем запись
        <span class="cov8" title="1">err = c.repo.DeleteUserData(userData.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при удалении текстовых данных: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package service

import "github.com/SmirnovND/gophkeeper/internal/interfaces"

type TokenService struct {
        ts interfaces.TokenStorage
}

func NewTokenService(ts interfaces.TokenStorage) interfaces.TokenService <span class="cov0" title="0">{
        return &amp;TokenService{
                ts: ts,
        }
}</span>

func (t *TokenService) SaveToken(token string) <span class="cov0" title="0">{
        t.ts.SaveToken(token)
}</span>

func (t *TokenService) LoadToken() (string, error) <span class="cov0" title="0">{
        return t.ts.LoadToken()
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package service

import (
        "github.com/SmirnovND/gophkeeper/internal/domain"
        "github.com/SmirnovND/gophkeeper/internal/interfaces"
)

type UserService struct {
        repo        interfaces.UserRepo
        authService interfaces.AuthService
}

func NewUserService(repo interfaces.UserRepo, AuthService interfaces.AuthService) interfaces.UserService <span class="cov8" title="1">{
        return &amp;UserService{
                repo:        repo,
                authService: AuthService,
        }
}</span>

func (u *UserService) FindUser(login string) (*domain.User, error) <span class="cov8" title="1">{
        return u.repo.FindUser(login)
}</span>

func (u *UserService) SaveUser(login string, pass string) (*domain.User, error) <span class="cov8" title="1">{
        user := &amp;domain.User{}
        user.Login = login

        hash, err := u.authService.HashPassword(pass)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">user.PassHash = hash

        err = u.repo.SaveUser(user)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return user, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package usecase

import (
        "fmt"
        "github.com/SmirnovND/gophkeeper/internal/domain"
        "github.com/SmirnovND/gophkeeper/internal/interfaces"
        "net/http"
)

type AuthUseCase struct {
        userService interfaces.UserService
        authService interfaces.AuthService
}

func NewAuthUseCase(
        UserService interfaces.UserService,
        AuthService interfaces.AuthService,
) interfaces.AuthUseCase <span class="cov8" title="1">{
        return &amp;AuthUseCase{
                userService: UserService,
                authService: AuthService,
        }
}</span>

func (a *AuthUseCase) Register(w http.ResponseWriter, credentials *domain.Credentials) (string, error) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")

        _, err := a.userService.FindUser(credentials.Login)
        if err == nil </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusConflict)
                return "", fmt.Errorf("user already exists")
        }</span>

        <span class="cov8" title="1">if err != domain.ErrNotFound </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return "", fmt.Errorf(err.Error()+" error finding user: %w", err)
        }</span>

        <span class="cov8" title="1">var user *domain.User

        user, err = a.userService.SaveUser(credentials.Login, credentials.Password)
        if err != nil </span><span class="cov8" title="1">{
                // Обработка ошибки сохранения пользователя
                http.Error(w, fmt.Sprintf("Error saving user: %v", err), http.StatusInternalServerError)
                return "", fmt.Errorf("error saving user: %w", err)
        }</span>

        <span class="cov8" title="1">token, err := a.authService.GenerateToken(user.Login)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, fmt.Sprintf("Error generating token: %v", err), http.StatusInternalServerError)
                return "", fmt.Errorf("error generating token: %w", err)
        }</span>

        <span class="cov8" title="1">a.authService.SetResponseAuthData(w, token)

        // Отправляем успешный ответ
        w.WriteHeader(http.StatusOK)
        w.Write([]byte(`{"status": "success"}`))

        return token, nil</span>
}

func (a *AuthUseCase) Login(w http.ResponseWriter, credentials *domain.Credentials) (string, error) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")

        user, err := a.userService.FindUser(credentials.Login)
        if err != nil </span><span class="cov8" title="1">{
                if err == domain.ErrNotFound </span><span class="cov8" title="1">{
                        http.Error(w, "Error: user not found", http.StatusUnauthorized)
                        return "", fmt.Errorf("user not found")
                }</span> else<span class="cov8" title="1"> {
                        http.Error(w, "Error: error finding user", http.StatusInternalServerError)
                        return "", fmt.Errorf("error finding user: %w", err)
                }</span>
        }

        // Проверяем пароль
        <span class="cov8" title="1">passValid := a.authService.CheckPasswordHash(credentials.Password, user.PassHash)
        if !passValid </span><span class="cov8" title="1">{
                http.Error(w, "Error: invalid password", http.StatusUnauthorized)
                return "", fmt.Errorf("invalid password")
        }</span>

        // Генерируем токен
        <span class="cov8" title="1">token, err := a.authService.GenerateToken(user.Login)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Error generating token", http.StatusInternalServerError)
                return "", fmt.Errorf("error generating token: %w", err)
        }</span>

        <span class="cov8" title="1">a.authService.SetResponseAuthData(w, token)

        // Отправляем успешный ответ
        w.WriteHeader(http.StatusOK)
        w.Write([]byte(`{"status": "success"}`))

        return token, nil</span>
}

// ValidateToken проверяет валидность JWT токена и возвращает claims
func (a *AuthUseCase) ValidateToken(token string) (*domain.Claims, error) <span class="cov8" title="1">{
        return a.authService.ValidateToken(token)
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package usecase

import (
        "errors"
        "fmt"
        "github.com/SmirnovND/gophkeeper/internal/domain"
        "github.com/SmirnovND/gophkeeper/internal/interfaces"
        "github.com/SmirnovND/gophkeeper/pkg"
        "os"
        "path/filepath"
        "strings"
)

type ClientUseCase struct {
        TokenService  interfaces.TokenService
        ClientService interfaces.ClientService
}

func NewClientUseCase(
        TokenService interfaces.TokenService,
        ClientService interfaces.ClientService,
) interfaces.ClientUseCase <span class="cov8" title="1">{
        return &amp;ClientUseCase{
                TokenService:  TokenService,
                ClientService: ClientService,
        }
}</span>

func (c *ClientUseCase) Login(username string, password string) error <span class="cov8" title="1">{
        // Получаем токен через ClientService
        token, err := c.ClientService.Login(username, password)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("ошибка при входе: %w", err)
        }</span>

        // Сохраняем полученный токен
        <span class="cov8" title="1">c.TokenService.SaveToken(token)
        return nil</span>
}

func (c *ClientUseCase) Register(username string, password string, passwordCheck string) error <span class="cov8" title="1">{
        if password != passwordCheck </span><span class="cov8" title="1">{
                return fmt.Errorf("пароли не совпадают")
        }</span>
        // Получаем токен через ClientService
        <span class="cov8" title="1">token, err := c.ClientService.Register(username, password)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("ошибка при регистрации: %w", err)
        }</span>

        // Сохраняем полученный токен
        <span class="cov8" title="1">c.TokenService.SaveToken(token)
        return nil</span>
}

// Upload - функция для загрузки файла на сервер.
func (c *ClientUseCase) Upload(filePath string, label string) (string, error) <span class="cov8" title="1">{
        // Проверяем, существует ли файл
        fileInfo, err := os.Stat(filePath)
        if err != nil </span><span class="cov8" title="1">{
                return "", errors.New(fmt.Sprintf("Ошибка при проверке файла: %v\n", err))
        }</span>

        // Проверяем, что это файл, а не директория
        <span class="cov8" title="1">if fileInfo.IsDir() </span><span class="cov8" title="1">{
                return "", errors.New("Указанный путь является директорией, а не файлом")
        }</span>

        // Проверяем тип файла (текстовый или бинарный)
        <span class="cov8" title="1">isText := isTextFile(filePath)
        isBinary := isBinaryFile(filePath)

        // Проверяем, что файл является текстовым или бинарным
        if !isText &amp;&amp; !isBinary </span><span class="cov8" title="1">{
                return "", errors.New("Файл не является ни текстовым, ни бинарным")
        }</span>

        // Открываем файл
        <span class="cov8" title="1">file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.New(fmt.Sprintf("Ошибка при открытии файла: %v\n", err))
        }</span>
        <span class="cov8" title="1">defer file.Close()

        token, err := c.TokenService.LoadToken()
        if err != nil </span><span class="cov8" title="1">{
                return "", errors.New(fmt.Sprintf("Ошибка при загрузке токена: %v\n", err))
        }</span>
        // Получение ссылки на загрузку файла
        <span class="cov8" title="1">url, err := c.ClientService.GetUploadLink(label, pkg.GetExtensionByPath(filePath), token)
        if err != nil </span><span class="cov8" title="1">{
                return "", errors.New(fmt.Sprintf("Ошибка при получении ссылки на загрузку: %v\n", err))
        }</span>

        // Выводим информацию о типе файла
        <span class="cov8" title="1">fileType := "бинарный"
        if isText </span><span class="cov8" title="1">{
                fileType = "текстовый"
        }</span>
        <span class="cov8" title="1">fmt.Printf("Загрузка %s файла: %s\n", fileType, filePath)

        return c.ClientService.SendFileToServer(url, file)</span>
}

// Download - функция для скачивания файла с сервера.
func (c *ClientUseCase) Download(label string) error <span class="cov8" title="1">{
        // Проверяем, что метка файла указана
        if label == "" </span><span class="cov8" title="1">{
                return errors.New("Не указана метка файла")
        }</span>

        // Загружаем токен
        <span class="cov8" title="1">token, err := c.TokenService.LoadToken()
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("ошибка при загрузке токена: %w", err)
        }</span>

        // Получаем ссылку на скачивание файла и метаданные
        <span class="cov8" title="1">downloadURL, fileMetadata, err := c.ClientService.GetDownloadLink(label, token)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("ошибка при получении ссылки на скачивание: %w", err)
        }</span>

        // Получаем директорию загрузок
        <span class="cov8" title="1">downloadsDir := pkg.GetDownloadsDir()
        // Формируем имя файла из метки и расширения
        fileName := fmt.Sprintf("%s.%s", label, fileMetadata.Extension)
        outputPath := filepath.Join(downloadsDir, fileName)

        fmt.Printf("Скачивание файла с меткой '%s'\n", label)

        // Скачиваем файл
        err = c.ClientService.DownloadFileFromServer(downloadURL, outputPath)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("ошибка при скачивании файла: %w", err)
        }</span>

        <span class="cov8" title="1">fmt.Printf("Файл успешно скачан и сохранен в '%s'\n", outputPath)
        return nil</span>
}

// SaveText сохраняет текстовые данные
func (c *ClientUseCase) SaveText(label string, textData *domain.TextData) error <span class="cov8" title="1">{
        // Проверяем, что метка указана
        if label == "" </span><span class="cov8" title="1">{
                return errors.New("не указана метка для текстовых данных")
        }</span>

        // Загружаем токен
        <span class="cov8" title="1">token, err := c.TokenService.LoadToken()
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("ошибка при загрузке токена: %w", err)
        }</span>

        // Сохраняем текстовые данные
        <span class="cov8" title="1">err = c.ClientService.SaveText(label, textData, token)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("ошибка при сохранении текстовых данных: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetText получает текстовые данные
func (c *ClientUseCase) GetText(label string) (*domain.TextData, error) <span class="cov8" title="1">{
        // Проверяем, что метка указана
        if label == "" </span><span class="cov8" title="1">{
                return nil, errors.New("не указана метка для текстовых данных")
        }</span>

        // Загружаем токен
        <span class="cov8" title="1">token, err := c.TokenService.LoadToken()
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("ошибка при загрузке токена: %w", err)
        }</span>

        // Получаем текстовые данные
        <span class="cov8" title="1">textData, err := c.ClientService.GetText(label, token)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("ошибка при получении текстовых данных: %w", err)
        }</span>

        <span class="cov8" title="1">return textData, nil</span>
}

// DeleteText удаляет текстовые данные
func (c *ClientUseCase) DeleteText(label string) error <span class="cov8" title="1">{
        // Проверяем, что метка указана
        if label == "" </span><span class="cov8" title="1">{
                return errors.New("не указана метка для текстовых данных")
        }</span>

        // Загружаем токен
        <span class="cov8" title="1">token, err := c.TokenService.LoadToken()
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("ошибка при загрузке токена: %w", err)
        }</span>

        // Удаляем текстовые данные
        <span class="cov8" title="1">err = c.ClientService.DeleteText(label, token)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("ошибка при удалении текстовых данных: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// SaveCard сохраняет данные кредитной карты
func (c *ClientUseCase) SaveCard(label string, cardData *domain.CardData) error <span class="cov8" title="1">{
        // Проверяем, что метка указана
        if label == "" </span><span class="cov0" title="0">{
                return errors.New("не указана метка для данных карты")
        }</span>

        // Загружаем токен
        <span class="cov8" title="1">token, err := c.TokenService.LoadToken()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при загрузке токена: %w", err)
        }</span>

        // Сохраняем данные карты
        <span class="cov8" title="1">err = c.ClientService.SaveCard(label, cardData, token)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при сохранении данных карты: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetCard получает данные кредитной карты
func (c *ClientUseCase) GetCard(label string) (*domain.CardData, error) <span class="cov8" title="1">{
        // Проверяем, что метка указана
        if label == "" </span><span class="cov0" title="0">{
                return nil, errors.New("не указана метка для данных карты")
        }</span>

        // Загружаем токен
        <span class="cov8" title="1">token, err := c.TokenService.LoadToken()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка при загрузке токена: %w", err)
        }</span>

        // Получаем данные карты
        <span class="cov8" title="1">cardData, err := c.ClientService.GetCard(label, token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка при получении данных карты: %w", err)
        }</span>

        <span class="cov8" title="1">return cardData, nil</span>
}

// DeleteCard удаляет данные кредитной карты
func (c *ClientUseCase) DeleteCard(label string) error <span class="cov8" title="1">{
        // Проверяем, что метка указана
        if label == "" </span><span class="cov0" title="0">{
                return errors.New("не указана метка для данных карты")
        }</span>

        // Загружаем токен
        <span class="cov8" title="1">token, err := c.TokenService.LoadToken()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при загрузке токена: %w", err)
        }</span>

        // Удаляем данные карты
        <span class="cov8" title="1">err = c.ClientService.DeleteCard(label, token)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при удалении данных карты: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// SaveCredential сохраняет учетные данные
func (c *ClientUseCase) SaveCredential(label string, credentialData *domain.CredentialData) error <span class="cov8" title="1">{
        // Проверяем, что метка указана
        if label == "" </span><span class="cov0" title="0">{
                return errors.New("не указана метка для учетных данных")
        }</span>

        // Загружаем токен
        <span class="cov8" title="1">token, err := c.TokenService.LoadToken()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при загрузке токена: %w", err)
        }</span>

        // Сохраняем учетные данные
        <span class="cov8" title="1">err = c.ClientService.SaveCredential(label, credentialData, token)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при сохранении учетных данных: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetCredential получает учетные данные
func (c *ClientUseCase) GetCredential(label string) (*domain.CredentialData, error) <span class="cov8" title="1">{
        // Проверяем, что метка указана
        if label == "" </span><span class="cov0" title="0">{
                return nil, errors.New("не указана метка для учетных данных")
        }</span>

        // Загружаем токен
        <span class="cov8" title="1">token, err := c.TokenService.LoadToken()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка при загрузке токена: %w", err)
        }</span>

        // Получаем учетные данные
        <span class="cov8" title="1">credentialData, err := c.ClientService.GetCredential(label, token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка при получении учетных данных: %w", err)
        }</span>

        <span class="cov8" title="1">return credentialData, nil</span>
}

// DeleteCredential удаляет учетные данные
func (c *ClientUseCase) DeleteCredential(label string) error <span class="cov8" title="1">{
        // Проверяем, что метка указана
        if label == "" </span><span class="cov0" title="0">{
                return errors.New("не указана метка для учетных данных")
        }</span>

        // Загружаем токен
        <span class="cov8" title="1">token, err := c.TokenService.LoadToken()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при загрузке токена: %w", err)
        }</span>

        // Удаляем учетные данные
        <span class="cov8" title="1">err = c.ClientService.DeleteCredential(label, token)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при удалении учетных данных: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// isTextFile проверяет, является ли файл текстовым
func isTextFile(filePath string) bool <span class="cov8" title="1">{
        // Проверка по расширению файла (быстрый метод)
        if ".txt" == strings.ToLower(filepath.Ext(filePath)) </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}

// isBinaryFile проверяет, является ли файл бинарным
func isBinaryFile(filePath string) bool <span class="cov8" title="1">{
        // Проверка по расширению файла (быстрый метод)
        if ".bin" == strings.ToLower(filepath.Ext(filePath)) </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package usecase

import (
        "encoding/json"
        "fmt"
        "github.com/SmirnovND/gophkeeper/internal/domain"
        "github.com/SmirnovND/gophkeeper/internal/interfaces"
        "github.com/SmirnovND/gophkeeper/pkg"
        "net/http"
)

type CloudUseCase struct {
        cloudService interfaces.CloudService
        dataService  interfaces.DataService
}

func NewCloudUseCase(
        cloudService interfaces.CloudService,
        dataService interfaces.DataService,
) interfaces.CloudUseCase <span class="cov0" title="0">{
        return &amp;CloudUseCase{
                cloudService: cloudService,
                dataService:  dataService,
        }
}</span>

func (c *CloudUseCase) GenerateUploadLink(w http.ResponseWriter, r *http.Request, fileData *domain.FileData) <span class="cov0" title="0">{
        login, err := pkg.ExtractLoginFromToken(r.Header.Get("Authorization"))
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Ошибка получения логина: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        // Валидация входящего объекта FileData
        <span class="cov0" title="0">if fileData == nil || fileData.Name == "" || fileData.Extension == "" </span><span class="cov0" title="0">{
                http.Error(w, "Неверные данные файла", http.StatusBadRequest)
                return
        }</span>

        // Формируем имя файла
        <span class="cov0" title="0">fileName := fmt.Sprintf("%s_%s.%s", login, fileData.Name, fileData.Extension)

        // Получаем ссылку для загрузки
        uploadLink, err := c.cloudService.GenerateUploadLink(fileName)

        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Ошибка при генерации ссылки: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        // Сохраняем метаданные файла в таблице user_data
        <span class="cov0" title="0">err = c.dataService.SaveFileMetadata(login, fileData.Name, fileData)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Ошибка при сохранении метаданных файла: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := domain.FileDataResponse{
                Url:         uploadLink,
                Description: "Загрузи файл по этой ссылке",
        }

        // Отправляем ответ
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(response)</span>
}

func (c *CloudUseCase) GenerateDownloadLink(w http.ResponseWriter, r *http.Request, label string) <span class="cov0" title="0">{
        // Получаем логин пользователя из токена
        login, err := pkg.ExtractLoginFromToken(r.Header.Get("Authorization"))
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Ошибка получения логина: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        // Валидация входящих данных
        <span class="cov0" title="0">if label == "" </span><span class="cov0" title="0">{
                http.Error(w, "Не указана метка файла", http.StatusBadRequest)
                return
        }</span>

        // Получаем метаданные файла из базы данных
        <span class="cov0" title="0">fileMetadata, err := c.dataService.GetFileMetadata(login, label)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Ошибка при получении метаданных файла: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        // Формируем имя файла
        <span class="cov0" title="0">fileName := fmt.Sprintf("%s_%s.%s", login, fileMetadata.FileName, fileMetadata.Extension)

        // Получаем ссылку для скачивания
        downloadLink, err := c.cloudService.GenerateDownloadLink(fileName)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Ошибка при генерации ссылки для скачивания: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        // Создаем расширенный ответ с метаданными
        <span class="cov0" title="0">response := struct {
                URL         string              `json:"url"`
                Description string              `json:"description"`
                Metadata    domain.FileMetadata `json:"metadata"`
        }{
                URL:         downloadLink,
                Description: "Скачай файл по этой ссылке",
                Metadata:    *fileMetadata,
        }

        // Отправляем ответ
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(response)</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package usecase

import (
        "encoding/json"
        "github.com/SmirnovND/gophkeeper/internal/domain"
        "github.com/SmirnovND/gophkeeper/internal/interfaces"
        "github.com/SmirnovND/gophkeeper/pkg"
        "net/http"
)

type DataUseCase struct {
        dataService interfaces.DataService
}

func NewDataUseCase(
        dataService interfaces.DataService,
) interfaces.DataUseCase <span class="cov8" title="1">{
        return &amp;DataUseCase{
                dataService: dataService,
        }
}</span>
func (c *DataUseCase) GetCredential(w http.ResponseWriter, r *http.Request, label string) <span class="cov8" title="1">{
        login, err := pkg.TokenExtractor(r.Header.Get("Authorization"))
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Ошибка получения логина: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">credentialData, err := c.dataService.GetCredential(login, label)
        if err != nil </span><span class="cov8" title="1">{
                if err.Error() == "учетные данные не найдены" </span><span class="cov8" title="1">{
                        http.Error(w, err.Error(), http.StatusNotFound)
                        return
                }</span>
                <span class="cov8" title="1">http.Error(w, err.Error(), http.StatusInternalServerError)
                return</span>
        }

        // Отправляем данные в ответе
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(credentialData)</span>
}

func (c *DataUseCase) SaveCredential(w http.ResponseWriter, r *http.Request, label string, credentialData *domain.CredentialData) <span class="cov8" title="1">{
        login, err := pkg.TokenExtractor(r.Header.Get("Authorization"))
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Ошибка получения логина: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        // Сохраняем данные
        <span class="cov8" title="1">err = c.dataService.SaveCredential(login, label, credentialData)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        // Отправляем успешный ответ
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"message": "учетные данные успешно сохранены"})</span>
}

func (c *DataUseCase) SaveCard(w http.ResponseWriter, r *http.Request, label string, cardData *domain.CardData) <span class="cov8" title="1">{
        login, err := pkg.TokenExtractor(r.Header.Get("Authorization"))
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Ошибка получения логина: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        // Сохраняем данные
        <span class="cov8" title="1">err = c.dataService.SaveCard(login, label, cardData)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        // Отправляем успешный ответ
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"message": "данные карты успешно сохранены"})</span>
}

func (c *DataUseCase) GetCard(w http.ResponseWriter, r *http.Request, label string) <span class="cov8" title="1">{
        login, err := pkg.TokenExtractor(r.Header.Get("Authorization"))
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Ошибка получения логина: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        // Получаем данные
        <span class="cov8" title="1">cardData, err := c.dataService.GetCard(login, label)
        if err != nil </span><span class="cov8" title="1">{
                if err.Error() == "данные карты не найдены" </span><span class="cov8" title="1">{
                        http.Error(w, err.Error(), http.StatusNotFound)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, err.Error(), http.StatusInternalServerError)
                return</span>
        }

        // Отправляем данные в ответе
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(cardData)</span>
}

func (c *DataUseCase) SaveText(w http.ResponseWriter, r *http.Request, label string, textData *domain.TextData) <span class="cov8" title="1">{
        login, err := pkg.TokenExtractor(r.Header.Get("Authorization"))
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Ошибка получения логина: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        // Сохраняем данные
        <span class="cov8" title="1">err = c.dataService.SaveText(login, label, textData)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        // Отправляем успешный ответ
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"message": "текстовые данные успешно сохранены"})</span>
}

func (c *DataUseCase) GetText(w http.ResponseWriter, r *http.Request, label string) <span class="cov8" title="1">{
        login, err := pkg.TokenExtractor(r.Header.Get("Authorization"))
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Ошибка получения логина: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        // Получаем данные
        <span class="cov8" title="1">textData, err := c.dataService.GetText(login, label)
        if err != nil </span><span class="cov8" title="1">{
                if err.Error() == "текстовые данные не найдены" </span><span class="cov8" title="1">{
                        http.Error(w, err.Error(), http.StatusNotFound)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, err.Error(), http.StatusInternalServerError)
                return</span>
        }

        // Отправляем данные в ответе
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(textData)</span>
}

func (c *DataUseCase) DeleteCredential(w http.ResponseWriter, r *http.Request, label string) <span class="cov8" title="1">{
        login, err := pkg.TokenExtractor(r.Header.Get("Authorization"))
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Ошибка получения логина: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        // Удаляем данные
        <span class="cov8" title="1">err = c.dataService.DeleteCredential(login, label)
        if err != nil </span><span class="cov8" title="1">{
                if err.Error() == "учетные данные не найдены" </span><span class="cov8" title="1">{
                        http.Error(w, err.Error(), http.StatusNotFound)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, err.Error(), http.StatusInternalServerError)
                return</span>
        }

        // Отправляем успешный ответ
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"message": "учетные данные успешно удалены"})</span>
}

func (c *DataUseCase) DeleteCard(w http.ResponseWriter, r *http.Request, label string) <span class="cov8" title="1">{
        login, err := pkg.TokenExtractor(r.Header.Get("Authorization"))
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Ошибка получения логина: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        // Удаляем данные
        <span class="cov8" title="1">err = c.dataService.DeleteCard(login, label)
        if err != nil </span><span class="cov8" title="1">{
                if err.Error() == "данные карты не найдены" </span><span class="cov8" title="1">{
                        http.Error(w, err.Error(), http.StatusNotFound)
                        return
                }</span>
                <span class="cov8" title="1">http.Error(w, err.Error(), http.StatusInternalServerError)
                return</span>
        }

        // Отправляем успешный ответ
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"message": "данные карты успешно удалены"})</span>
}

func (c *DataUseCase) DeleteText(w http.ResponseWriter, r *http.Request, label string) <span class="cov8" title="1">{
        login, err := pkg.TokenExtractor(r.Header.Get("Authorization"))
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Ошибка получения логина: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        // Удаляем данные
        <span class="cov8" title="1">err = c.dataService.DeleteText(login, label)
        if err != nil </span><span class="cov8" title="1">{
                if err.Error() == "текстовые данные не найдены" </span><span class="cov8" title="1">{
                        http.Error(w, err.Error(), http.StatusNotFound)
                        return
                }</span>
                <span class="cov8" title="1">http.Error(w, err.Error(), http.StatusInternalServerError)
                return</span>
        }

        // Отправляем успешный ответ
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"message": "текстовые данные успешно удалены"})</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package pkg

import (
        "errors"
        "fmt"
        "strings"

        "github.com/golang-jwt/jwt/v4"
)

// ExtractLoginFromToken извлекает значение поля login из JWT токена.
// Токен должен быть в формате "Bearer &lt;jwt-token&gt;".
func ExtractLoginFromToken(tokenString string) (string, error) <span class="cov8" title="1">{
        // Проверяем, что токен начинается с "Bearer "
        if !strings.HasPrefix(tokenString, "Bearer ") </span><span class="cov8" title="1">{
                return "", errors.New("токен должен начинаться с 'Bearer '")
        }</span>

        // Удаляем префикс "Bearer "
        <span class="cov8" title="1">tokenString = strings.TrimPrefix(tokenString, "Bearer ")

        // Парсим JWT токен
        token, _, err := new(jwt.Parser).ParseUnverified(tokenString, jwt.MapClaims{})
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("ошибка при парсинге токена: %w", err)
        }</span>

        // Извлекаем claims из токена
        <span class="cov8" title="1">claims, ok := token.Claims.(jwt.MapClaims)
        if !ok </span><span class="cov0" title="0">{
                return "", errors.New("не удалось извлечь claims из токена")
        }</span>

        // Извлекаем значение поля login
        <span class="cov8" title="1">login, ok := claims["login"].(string)
        if !ok </span><span class="cov8" title="1">{
                return "", errors.New("поле 'login' отсутствует в токене или имеет неверный формат")
        }</span>

        <span class="cov8" title="1">return login, nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package pkg

import (
        "os"
        "path/filepath"
        "runtime"
)

// UserHomeDirFunc определяет тип функции для получения домашней директории пользователя
type UserHomeDirFunc func() (string, error)

// Переменная, содержащая функцию для получения домашней директории
// По умолчанию использует os.UserHomeDir, но может быть переопределена для тестов
var userHomeDirFunc UserHomeDirFunc = os.UserHomeDir

// GetOSFunc определяет тип функции для получения текущей операционной системы
type GetOSFunc func() string

// Переменная, содержащая функцию для получения текущей операционной системы
// По умолчанию возвращает runtime.GOOS, но может быть переопределена для тестов
var getOSFunc GetOSFunc = func() string <span class="cov0" title="0">{
        return runtime.GOOS
}</span>

// GetDownloadsDir возвращает путь к директории загрузок пользователя
func GetDownloadsDir() string <span class="cov8" title="1">{
        // Получаем домашнюю директорию пользователя
        homeDir, err := userHomeDirFunc()
        if err != nil </span><span class="cov8" title="1">{
                // Если не удалось получить домашнюю директорию, используем текущую
                return "."
        }</span>

        // В зависимости от операционной системы, выбираем путь к директории загрузок
        <span class="cov8" title="1">switch getOSFunc() </span>{
        case "windows":<span class="cov8" title="1">
                return filepath.Join(homeDir, "Downloads")</span>
        case "darwin":<span class="cov8" title="1"> // macOS
                return filepath.Join(homeDir, "Downloads")</span>
        default:<span class="cov8" title="1"> // Linux и другие Unix-подобные системы
                // Проверяем существование директории XDG_DOWNLOAD_DIR
                xdgConfigHome := os.Getenv("XDG_CONFIG_HOME")
                if xdgConfigHome == "" </span><span class="cov8" title="1">{
                        xdgConfigHome = filepath.Join(homeDir, ".config")
                }</span>

                // Проверяем наличие файла user-dirs.dirs
                <span class="cov8" title="1">userDirsFile := filepath.Join(xdgConfigHome, "user-dirs.dirs")
                if _, err := os.Stat(userDirsFile); err == nil </span><span class="cov0" title="0">{
                        // Если файл существует, можно было бы прочитать его и найти XDG_DOWNLOAD_DIR
                        // Но для простоты используем стандартный путь
                        return filepath.Join(homeDir, "Downloads")
                }</span>

                // Если не нашли конфигурацию, используем стандартный путь
                <span class="cov8" title="1">return filepath.Join(homeDir, "Downloads")</span>
        }
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package pkg

func GetExtensionByPath(filePath string) string <span class="cov8" title="1">{
        // Извлекаем расширение файла из пути
        extension := ""
        lastDotIndex := -1
        for i := len(filePath) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                if filePath[i] == '.' </span><span class="cov8" title="1">{
                        lastDotIndex = i
                        break</span>
                }
                <span class="cov8" title="1">if filePath[i] == '/' || filePath[i] == '\\' </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov8" title="1">if lastDotIndex != -1 </span><span class="cov8" title="1">{
                extension = filePath[lastDotIndex+1:]
        }</span>

        <span class="cov8" title="1">return extension</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
